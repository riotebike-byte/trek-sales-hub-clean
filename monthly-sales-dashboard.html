<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aylık Satış Analiz Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.8em;
            margin-bottom: 10px;
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        .upload-area {
            border: 2px dashed #3498db;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            background: #f8f9fa;
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #2980b9;
            background: #e8f4f8;
        }

        .upload-area.dragover {
            border-color: #27ae60;
            background: #e8f8f0;
        }

        #fileInput {
            display: none;
        }

        .upload-text {
            font-size: 18px;
            color: #666;
            margin-bottom: 15px;
        }

        .upload-btn {
            background: #3498db;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .upload-btn:hover {
            background: #2980b9;
        }

        .analysis-section {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #3498db;
        }

        .stat-card h3 {
            color: #2c3e50;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #3498db;
        }

        .stores-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .store-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
            transition: background 0.3s;
        }

        .store-item:hover {
            background: #f8f9fa;
        }

        .store-name {
            font-weight: 600;
            color: #2c3e50;
            font-size: 16px;
        }

        .store-stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .store-amount {
            font-size: 18px;
            font-weight: bold;
            color: #27ae60;
        }

        .store-count {
            font-size: 14px;
            color: #666;
            background: #ecf0f1;
            padding: 4px 8px;
            border-radius: 12px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .success {
            background: #27ae60;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .currency-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .currency-btn {
            padding: 8px 16px;
            border: 2px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .currency-btn.active {
            background: #3498db;
            color: white;
        }

        .file-info {
            margin-top: 15px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 6px;
            font-size: 14px;
            color: #2c3e50;
        }

        .section-btn {
            padding: 10px 20px;
            border: 2px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .section-btn.active {
            background: #3498db;
            color: white;
        }

        .section-btn:hover:not(.active) {
            background: #e8f4f8;
        }

        .chart-btn {
            padding: 10px 20px;
            border: 2px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 14px;
        }

        .chart-btn.active {
            background: #3498db;
            color: white;
        }

        .chart-btn:hover:not(.active) {
            background: #e8f4f8;
        }

        .chart-container {
            animation: fadeIn 0.3s ease-in;
        }

        .performance-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .performance-category {
            font-weight: 600;
            color: #2c3e50;
        }

        .performance-stats {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .performance-amount {
            font-size: 18px;
            font-weight: bold;
            color: #27ae60;
        }

        .performance-count {
            font-size: 14px;
            color: #666;
            background: #ecf0f1;
            padding: 4px 8px;
            border-radius: 12px;
        }

        .tab-content {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Memory Management Styles */
        #memoryStatus {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .memory-file {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }

        .file-name {
            font-weight: 600;
            color: #2c3e50;
        }

        .file-info {
            font-size: 12px;
            color: #6c757d;
        }

        .remove-btn {
            background: #dc3545;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-btn:hover {
            background: #c82333;
        }

        .dealer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
            transition: background 0.3s;
            background: linear-gradient(90deg, #fff 0%, #f8f9fa 100%);
        }

        .dealer-item:hover {
            background: linear-gradient(90deg, #e8f4f8 0%, #f0f8ff 100%);
        }

        .dealer-name {
            font-weight: 600;
            color: #2c3e50;
            font-size: 16px;
        }

        .dealer-type {
            font-size: 12px;
            color: #666;
            background: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 8px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2.2em;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .store-stats {
                flex-direction: column;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📊 Aylık Satış Analiz Dashboard</h1>
            <p>Excel satış raporu yükleyerek aylık satış analizlerini görüntüleyin</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" onclick="document.getElementById('fileInput').click()">
                <div class="upload-text">📁 Excel dosyasını buraya sürükleyin veya tıklayarak seçin</div>
                <button class="upload-btn">Dosya Seç</button>
                <input type="file" id="fileInput" accept=".xlsx,.xls" />
            </div>
            <div class="file-info" id="fileInfo" style="display: none;"></div>
            
            <!-- Quick Actions -->
            <div id="quickActions" style="margin-top: 15px; display: none;">
                <button onclick="showYearlyAnalysis()" class="section-btn" style="margin-right: 10px;">📅 Yıllık Analiz</button>
                <button onclick="excelMemory.files.clear(); excelMemory.updateMemoryDisplay();" class="section-btn" style="background: #dc3545; border-color: #dc3545;">🗑️ Tümünü Temizle</button>
            </div>
            
            <!-- Exchange Rates Info -->
            <div id="exchangeRatesInfo" style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; font-size: 12px; color: #666; display: none;">
                <strong>💱 Döviz Kurları (2025 Ocak-Temmuz Ortalaması):</strong><br>
                1 USD = ₺${exchangeRates.USD.toFixed(3)} | 1 EUR = ₺${exchangeRates.EUR.toFixed(3)} | EUR/USD = ${(1.1096).toFixed(4)}
                <div style="margin-top: 5px; font-size: 11px;">
                    <em>Kaynak: Piyasa verisi analizi</em>
                </div>
            </div>

            <!-- Memory Status -->
            <div id="memoryStatus" style="margin-top: 20px; display: none;"></div>
        </div>

        <div class="loading" id="loading">
            <div>📊 Excel dosyası analiz ediliyor...</div>
        </div>

        <div class="analysis-section" id="analysisSection">
            <div class="currency-toggle">
                <button class="currency-btn active" onclick="toggleCurrency('TL')">TL</button>
                <button class="currency-btn" onclick="toggleCurrency('USD')">USD</button>
                <button class="currency-btn" onclick="toggleCurrency('EUR')">EUR</button>
            </div>

            <div class="period-info" id="periodInfo" style="margin-bottom: 20px; text-align: center; font-size: 16px; color: #2c3e50; background: #ecf0f1; padding: 10px; border-radius: 8px;">
                📅 Rapor Dönemi: -
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <h3>💰 Toplam Satış (Tüm Para Birimleri)</h3>
                    <div class="stat-value" id="totalSales">-</div>
                    <div class="currency-breakdown" id="currencyBreakdown" style="font-size: 14px; margin-top: 10px; color: #666;">
                        <div>🇺🇸 USD: <span id="totalUSD">-</span></div>
                        <div>🇪🇺 EUR: <span id="totalEUR">-</span></div>  
                        <div>🇹🇷 TL: <span id="totalTL">-</span></div>
                    </div>
                </div>
                <div class="stat-card">
                    <h3>📦 Toplam Adet</h3>
                    <div class="stat-value" id="totalQuantity">-</div>
                </div>
                <div class="stat-card">
                    <h3>🚲 Bisiklet Satışı</h3>
                    <div class="stat-value" id="bicycleSales">-</div>
                </div>
                <div class="stat-card">
                    <h3>🔧 Aksesuar/Parça</h3>
                    <div class="stat-value" id="accessorySales">-</div>
                </div>
                <div class="stat-card">
                    <h3>🚲 Bisiklet Adedi</h3>
                    <div class="stat-value" id="bicycleQuantity">-</div>
                </div>
                <div class="stat-card">
                    <h3>🔧 Aksesuar Adedi</h3>
                    <div class="stat-value" id="accessoryQuantity">-</div>
                </div>
                <div class="stat-card">
                    <h3>🏪 Mağaza/Bayi</h3>
                    <div class="stat-value" id="storeCount">-</div>
                </div>
                <div class="stat-card">
                    <h3>👥 Toplam Müşteri</h3>
                    <div class="stat-value" id="customerCount">-</div>
                </div>
            </div>

            <div class="stores-section">
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="section-btn active" onclick="showSection('stores')">🏪 Mağaza Satışları</button>
                    <button class="section-btn" onclick="showSection('dealers')">🤝 Bayi Satışları</button>
                </div>
                
                <div id="storesTab" class="tab-content">
                    <h3 style="margin-bottom: 20px;">🏪 Mağaza Bazında Satışlar</h3>
                    <div id="storesList"></div>
                </div>
                
                <div id="dealersTab" class="tab-content" style="display: none;">
                    <h3 style="margin-bottom: 20px;">🤝 Bayi Bazında Satışlar</h3>
                    <div id="dealersList"></div>
                </div>
            </div>
            
            <div class="chart-section" style="margin-top: 30px; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);">
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="chart-btn active" onclick="showChart('stores')">🏪 Mağaza/Bayi Satışları</button>
                    <button class="chart-btn" onclick="showChart('categories')">📊 Kategori Analizi</button>
                    <button class="chart-btn" onclick="showChart('performance')">🏆 En İyi Performans</button>
                    <button class="chart-btn" onclick="showChart('monthly')">📈 Aylık Trend</button>
                    <button class="chart-btn" onclick="showChart('monthlySales')">💰 USD Satış Trendi</button>
                </div>
                
                <div id="storesChart" class="chart-container">
                    <h3 style="margin-bottom: 15px;">🏪 Mağaza ve Bayi Satış Performansı</h3>
                    <canvas id="salesChart" width="400" height="200"></canvas>
                </div>
                
                <div id="categoriesChart" class="chart-container" style="display: none;">
                    <h3 style="margin-bottom: 15px;">📊 Kategori Bazlı Satış Analizi</h3>
                    <canvas id="categoryChart" width="400" height="200"></canvas>
                </div>
                
                <div id="performanceChart" class="chart-container" style="display: none;">
                    <h3 style="margin-bottom: 15px;">🏆 En İyi Performans Gösteren Kategoriler</h3>
                    <div id="performanceAnalysis"></div>
                    <canvas id="performanceChartCanvas" width="400" height="200"></canvas>
                </div>
                
                <div id="monthlyChart" class="chart-container" style="display: none;">
                    <h3 style="margin-bottom: 15px;">📈 Aylık Kategori Trendi</h3>
                    <p style="color: #666; font-style: italic; margin-bottom: 15px;">
                        💡 Bu grafik birden fazla aylık veri yüklendiğinde kategori trendlerini gösterecektir
                    </p>
                    <canvas id="monthlyTrendChart" width="400" height="200"></canvas>
                </div>
                
                <div id="monthlySalesChart" class="chart-container" style="display: none;">
                    <h3 style="margin-bottom: 15px;">💰 Aylık Toplam Satış Trendi (USD)</h3>
                    <canvas id="monthlySalesCanvas" width="400" height="200"></canvas>
                    <div id="monthlySalesStats" style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 14px;">
                        <div class="stats-row" style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span><strong>📊 İstatistikler:</strong></span>
                        </div>
                        <div id="monthlyStatsContent"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let currentData = null;
        let currentCurrency = 'TL';
        
        // Memory management for multiple Excel files
        const excelMemory = {
            files: new Map(), // fileName -> {data, uploadDate, fileSize}
            maxFiles: 12, // Keep max 12 months
            getCurrentFiles: function() {
                return Array.from(this.files.entries()).map(([name, info]) => ({
                    name,
                    uploadDate: info.uploadDate,
                    fileSize: info.fileSize,
                    dataSize: info.data ? info.data.sales?.length || 0 : 0
                }));
            },
            addFile: function(fileName, data, fileSize) {
                // Clean up old files if we exceed maxFiles
                if (this.files.size >= this.maxFiles) {
                    const oldestEntry = Array.from(this.files.entries())
                        .sort((a, b) => new Date(a[1].uploadDate) - new Date(b[1].uploadDate))[0];
                    this.files.delete(oldestEntry[0]);
                    console.log(`🗑️ Removed old file from memory: ${oldestEntry[0]}`);
                }
                
                this.files.set(fileName, {
                    data: data,
                    uploadDate: new Date().toISOString(),
                    fileSize: fileSize
                });
                
                console.log(`💾 Added to memory: ${fileName} (${this.files.size}/${this.maxFiles} files)`);
                this.updateMemoryDisplay();
            },
            removeFile: function(fileName) {
                this.files.delete(fileName);
                this.updateMemoryDisplay();
            },
            getAllData: function() {
                const allData = {
                    totalSales: 0,
                    totalQuantity: 0,
                    categories: {},
                    dealers: {},
                    stores: {},
                    monthlyBreakdown: {},
                    files: []
                };
                
                for (const [fileName, info] of this.files.entries()) {
                    if (info.data) {
                        allData.files.push(fileName);
                        allData.totalSales += info.data.totalSales || 0;
                        allData.totalQuantity += info.data.totalQuantity || 0;
                        
                        // Merge categories
                        for (const [cat, amount] of Object.entries(info.data.categorySales || {})) {
                            allData.categories[cat] = (allData.categories[cat] || 0) + amount;
                        }
                        
                        // Merge dealers
                        for (const [dealer, amount] of Object.entries(info.data.dealerSales || {})) {
                            allData.dealers[dealer] = (allData.dealers[dealer] || 0) + amount;
                        }
                        
                        // Merge stores
                        for (const [store, amount] of Object.entries(info.data.storeSales || {})) {
                            allData.stores[store] = (allData.stores[store] || 0) + amount;
                        }
                        
                        // Extract month from filename or date
                        const month = this.extractMonth(fileName);
                        if (month) {
                            allData.monthlyBreakdown[month] = (allData.monthlyBreakdown[month] || 0) + (info.data.totalSales || 0);
                        }
                    }
                }
                
                return allData;
            },
            extractMonth: function(fileName) {
                // Try to extract month from filename patterns like "SATIŞ RAPORU-10.xlsx" or "2025-07-sales.xlsx"
                const patterns = [
                    /(\d{4})-(\d{2})/,  // 2025-07
                    /(\d{2})\.xlsx?$/,   // -10.xlsx
                    /(ocak|şubat|mart|nisan|mayıs|haziran|temmuz|ağustos|eylül|ekim|kasım|aralık)/i
                ];
                
                for (const pattern of patterns) {
                    const match = fileName.match(pattern);
                    if (match) {
                        if (pattern === patterns[1]) {
                            return `2025-${match[1].padStart(2, '0')}`;
                        } else if (pattern === patterns[2]) {
                            const monthNames = {
                                'ocak': '01', 'şubat': '02', 'mart': '03', 'nisan': '04',
                                'mayıs': '05', 'haziran': '06', 'temmuz': '07', 'ağustos': '08',
                                'eylül': '09', 'ekim': '10', 'kasım': '11', 'aralık': '12'
                            };
                            return `2025-${monthNames[match[1].toLowerCase()]}`;
                        } else {
                            return `${match[1]}-${match[2]}`;
                        }
                    }
                }
                return null;
            },
            updateMemoryDisplay: function() {
                const files = this.getCurrentFiles();
                const memoryDiv = document.getElementById('memoryStatus');
                const actionsDiv = document.getElementById('quickActions');
                
                if (!memoryDiv) return;
                
                if (files.length > 0) {
                    actionsDiv.style.display = 'block';
                    
                    let html = `<h4>📚 Hafızadaki Excel Dosyaları (${files.length}/${this.maxFiles})</h4>`;
                    files.forEach(file => {
                        const date = new Date(file.uploadDate).toLocaleDateString('tr-TR');
                        const size = (file.fileSize / 1024).toFixed(1);
                        html += `
                            <div class="memory-file">
                                <span class="file-name">${file.name}</span>
                                <span class="file-info">${date} | ${size}KB | ${file.dataSize} satır</span>
                                <button onclick="excelMemory.removeFile('${file.name}')" class="remove-btn">🗑️</button>
                            </div>
                        `;
                    });
                    memoryDiv.innerHTML = html;
                } else {
                    actionsDiv.style.display = 'none';
                    memoryDiv.innerHTML = '';
                }
            }
        };
        let monthlyDataHistory = []; // Store multiple months data for trend analysis
        
        // BizimHesap products data cache
        let bizimhesapProducts = null;
        
        // Chart instances
        let salesChartInstance = null;
        let categoryChartInstance = null;
        let performanceChartInstance = null;
        let monthlyTrendChartInstance = null;
        let monthlySalesChartInstance = null;
        
        // Load BizimHesap product data for category analysis
        // Enhanced SKU-based product database for Trek products
        const trekProductDatabase = {
            // E-Bikes (High-end)
            '5325334': { category: 'E-BİKE', subCategory: 'Rail 9.8', type: 'bicycle', mainCategory: 'E-BİKELER' },
            '5322911': { category: 'E-BİKE', subCategory: 'Powerfly FS+ 6', type: 'bicycle', mainCategory: 'E-BİKELER' },
            '5272065': { category: 'E-BİKE', subCategory: 'Fuel EXe 9.9', type: 'bicycle', mainCategory: 'E-BİKELER' },
            '5315136': { category: 'E-BİKE', subCategory: 'Rail+ 5', type: 'bicycle', mainCategory: 'E-BİKELER' },
            '5324290': { category: 'E-BİKE', subCategory: 'Powerfly 4', type: 'bicycle', mainCategory: 'E-BİKELER' },
            '5324291': { category: 'E-BİKE', subCategory: 'Rail 5', type: 'bicycle', mainCategory: 'E-BİKELER' },
            
            // Road Bikes
            '582181': { category: 'YOL BİSİKLETİ', subCategory: 'Émonda SL 6', type: 'bicycle', mainCategory: 'YOL BİSİKLETLERİ' },
            '555607': { category: 'YOL BİSİKLETİ', subCategory: 'Domane AL 2', type: 'bicycle', mainCategory: 'YOL BİSİKLETLERİ' },
            
            // Mountain Bikes
            '593775': { category: 'DAĞ BİSİKLETİ', subCategory: 'X-Caliber 8', type: 'bicycle', mainCategory: 'DAĞ BİSİKLETLERİ' },
            '562401': { category: 'DAĞ BİSİKLETİ', subCategory: 'Marlin 7', type: 'bicycle', mainCategory: 'DAĞ BİSİKLETLERİ' },
            
            // Helmets
            '460497': { category: 'KASK', subCategory: 'Solstice MIPS', type: 'accessory', mainCategory: 'KASKLAR' },
            '578853': { category: 'KASK', subCategory: 'Circuit MIPS', type: 'accessory', mainCategory: 'KASKLAR' },
            '13458024': { category: 'KASK', subCategory: 'Velocis MIPS', type: 'accessory', mainCategory: 'KASKLAR' },
            
            // Clothing & Accessories
            '13407158': { category: 'GİYİM', subCategory: 'Bontrager Jersey', type: 'accessory', mainCategory: 'GİYİM' },
            '13428290': { category: 'GİYİM', subCategory: 'Trek Short', type: 'accessory', mainCategory: 'GİYİM' },
            
            // Components & Parts
            '13540566': { category: 'PARÇA', subCategory: 'Bontrager Component', type: 'accessory', mainCategory: 'PARÇALAR' },
            '13540567': { category: 'PARÇA', subCategory: 'Trek Component', type: 'accessory', mainCategory: 'PARÇALAR' },
            
            // Eyewear
            '100': { category: 'GÖZLÜK', subCategory: '100% Speedcraft', type: 'accessory', mainCategory: 'GÖZLÜKLER' },
            '200': { category: 'GÖZLÜK', subCategory: '100% S2', type: 'accessory', mainCategory: 'GÖZLÜKLER' },
            
            // Pattern-based matching for bulk accessories
            // Any code starting with '1345' = Bontrager accessories
            // Any code starting with '1354' = Trek components
            // Any code starting with '578' = Helmets
        };

        async function loadBizimHesapProducts() {
            if (bizimhesapProducts) return bizimhesapProducts;
            
            try {
                console.log('🔄 Loading BizimHesap products...');
                
                // Try proxy server first
                const response = await fetch('http://localhost:3002/api/b2b/products', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('🔍 BizimHesap API response structure:', data);
                
                if (data.data && data.data.products) {
                    bizimhesapProducts = data.data.products;
                    console.log(`✅ Loaded ${bizimhesapProducts.length} BizimHesap products from API`);
                    return bizimhesapProducts;
                } else if (data.products) {
                    bizimhesapProducts = data.products;
                    console.log(`✅ Loaded ${bizimhesapProducts.length} BizimHesap products from API`);
                    return bizimhesapProducts;
                } else {
                    console.log('⚠️ Unexpected API response structure:', Object.keys(data));
                    throw new Error('Invalid API response structure');
                }
            } catch (error) {
                console.error('❌ Failed to load BizimHesap products from API:', error);
                console.log('🔄 Using local Trek product database fallback');
                
                // Convert local database to API-like structure
                bizimhesapProducts = Object.entries(trekProductDatabase).map(([code, info]) => ({
                    code: code,
                    sku: code,
                    title: info.subCategory,
                    category: info.category,
                    sub_category: info.subCategory,
                    type: info.type,
                    main_category: info.mainCategory
                }));
                
                console.log(`✅ Loaded ${bizimhesapProducts.length} products from local Trek database`);
                return bizimhesapProducts;
            }
        }

        // Main category mapping for BizimHesap categories
        function getMainCategory(category) {
            if (!category) return 'UNCATEGORIZED';
            
            const cat = category.toUpperCase();
            
            // Bicycle main categories
            if (cat.includes('BISIKLET') || cat.includes('BIKE')) return 'BİSİKLETLER';
            
            // Accessory main categories
            if (cat.includes('POMPA')) return 'POMPALAR';
            if (cat.includes('KASK') || cat.includes('HELMET')) return 'KASKLAR';
            if (cat.includes('AYDINLATMA') || cat.includes('IŞIK') || cat.includes('LIGHT')) return 'AYDINLATMA';
            if (cat.includes('BAGAJ') || cat.includes('SEPET') || cat.includes('ÇANTA')) return 'BAGAJ & SEPET';
            if (cat.includes('LASTIK') || cat.includes('TIRE')) return 'LASTİKLER';
            if (cat.includes('ZINCIR') || cat.includes('CHAIN')) return 'ZİNCİR & AKTARMA';
            if (cat.includes('FREN') || cat.includes('BRAKE')) return 'FREN SİSTEMLERİ';
            if (cat.includes('PEDAL')) return 'PEDALLAR';
            if (cat.includes('SELE') || cat.includes('SADDLE')) return 'SELELER';
            if (cat.includes('GİDON') || cat.includes('HANDLEBAR')) return 'GİDONLAR';
            if (cat.includes('MATARA') || cat.includes('BOTTLE')) return 'MATARALAR';
            if (cat.includes('KILIT') || cat.includes('LOCK')) return 'KİLİTLER';
            if (cat.includes('ANAHTAR')) return 'ANAHTAR TAKIMI';
            if (cat.includes('TAŞIYICI') || cat.includes('CARRIER')) return 'TAŞIYICILAR';
            
            // Return original category if no main category found
            return category;
        }
        
        // Determine if product is bicycle or accessory
        function getBicycleOrAccessory(category) {
            if (!category) return 'accessory';
            
            const cat = category.toUpperCase();
            
            // Bicycle indicators
            if (cat.includes('BISIKLET') || cat.includes('BIKE') || cat.includes('CYCLE')) {
                return 'bicycle';
            }
            
            // Everything else is accessory
            return 'accessory';
        }

        // Enhanced product categorization using local database + API fallback
        function categorizeProduct(productCode, productName) {
            // Ensure parameters are defined
            productCode = productCode || '';
            productName = productName || '';
            
            console.log(`\n🔍 === CATEGORIZING PRODUCT ===`);
            console.log(`📋 Name: "${productName}"`);
            console.log(`🏷️  Code: "${productCode}" (type: ${typeof productCode})`);
            console.log(`📦 BizimHesap products loaded: ${bizimhesapProducts ? bizimhesapProducts.length : 'NOT LOADED'}`);
            
            // First try local Trek database lookup by code matching (most accurate)
            if (productCode && trekProductDatabase[String(productCode)]) {
                const localProduct = trekProductDatabase[String(productCode)];
                console.log(`🎯 LOCAL DATABASE EXACT MATCH: Code "${productCode}" → ${localProduct.subCategory} (${localProduct.category})`);
                
                return {
                    type: localProduct.type,
                    category: localProduct.subCategory,
                    mainCategory: localProduct.mainCategory,
                    source: 'LOCAL_DB_EXACT'
                };
            }
            
            // Pattern-based matching for common SKU patterns
            if (productCode) {
                const code = String(productCode);
                
                // Bontrager accessories (13458xxx series)
                if (code.startsWith('1345')) {
                    console.log(`🎯 PATTERN MATCH: Code "${productCode}" → Bontrager Accessory (Pattern: 1345xxxx)`);
                    return {
                        type: 'accessory',
                        category: 'Bontrager Accessory',
                        mainCategory: 'BONTRAGER AKSESUARLARI',
                        source: 'PATTERN_1345'
                    };
                }
                
                // Trek components (13540xxx series)
                if (code.startsWith('1354')) {
                    console.log(`🎯 PATTERN MATCH: Code "${productCode}" → Trek Component (Pattern: 1354xxxx)`);
                    return {
                        type: 'accessory',
                        category: 'Trek Component',
                        mainCategory: 'TREK PARÇALARI',
                        source: 'PATTERN_1354'
                    };
                }
                
                // Helmets (578xxx series)
                if (code.startsWith('578')) {
                    console.log(`🎯 PATTERN MATCH: Code "${productCode}" → Helmet (Pattern: 578xxx)`);
                    return {
                        type: 'accessory',
                        category: 'Helmet',
                        mainCategory: 'KASKLAR',
                        source: 'PATTERN_578'
                    };
                }
                
                // High-end bikes (5xxxxxx series)
                if (code.startsWith('5') && code.length >= 6) {
                    console.log(`🎯 PATTERN MATCH: Code "${productCode}" → Trek Bicycle (Pattern: 5xxxxxx)`);
                    return {
                        type: 'bicycle',
                        category: 'Trek Bicycle',
                        mainCategory: 'TREK BİSİKLETLER',
                        source: 'PATTERN_5X'
                    };
                }
                
                // 100% Eyewear (100-999 range)
                if (code.length <= 3 && /^\d+$/.test(code)) {
                    const num = parseInt(code);
                    if (num >= 100 && num <= 999) {
                        console.log(`🎯 PATTERN MATCH: Code "${productCode}" → 100% Eyewear (Pattern: 1xx-9xx)`);
                        return {
                            type: 'accessory',
                            category: '100% Eyewear',
                            mainCategory: 'GÖZLÜKLER',
                            source: 'PATTERN_100'
                        };
                    }
                }
            }
            
            // Second try API/loaded products lookup by code matching
            if (bizimhesapProducts && bizimhesapProducts.length > 0) {
                let apiProduct = null;
                
                // Priority 1: Exact code match with stock_code (most reliable)  
                if (productCode) {
                    // Convert both to string and clean whitespace for comparison
                    const excelCode = String(productCode).trim();
                    console.log(`🔍 Searching for Excel code: "${excelCode}"`);
                    
                    // Debug: show first few API products
                    if (bizimhesapProducts.length > 0) {
                        console.log(`📊 Sample API products (first 3):`);
                        bizimhesapProducts.slice(0, 3).forEach((p, i) => {
                            console.log(`  ${i+1}. Code: "${p.code}", Barcode: "${p.barcode}", Title: "${p.title}", Category: "${p.category}"`);
                        });
                    }
                    
                    apiProduct = bizimhesapProducts.find(p => {
                        const apiCode = String(p.code || '').trim();
                        const apiBarcode = String(p.barcode || '').trim();
                        const apiSku = String(p.sku || '').trim();
                        
                        const matches = apiCode === excelCode || 
                                       apiBarcode === excelCode || 
                                       apiSku === excelCode;
                        
                        if (matches) {
                            console.log(`✅ MATCH FOUND! Excel "${excelCode}" === API "${apiCode}" (${p.title})`);
                        }
                        
                        return matches;
                    });
                    
                    if (apiProduct) {
                        console.log(`🎯 API EXACT CODE MATCH: Excel code "${excelCode}" → API product "${apiProduct.title}"`);
                        console.log(`📋 API Product Details:`, {
                            code: apiProduct.code,
                            barcode: apiProduct.barcode,
                            category: apiProduct.category,
                            brand: apiProduct.brand,
                            title: apiProduct.title
                        });
                        
                        const productCategory = apiProduct.category || 'UNCATEGORIZED';
                        const productType = getBicycleOrAccessory(productCategory);
                        const mainCat = getMainCategory(productCategory);
                        
                        console.log(`🎯 CATEGORIZED: "${productCategory}" → Main: "${mainCat}", Type: "${productType}"`);
                        
                        return {
                            type: productType,
                            category: productCategory,
                            mainCategory: mainCat,
                            source: 'API_EXACT'
                        };
                    } else {
                        console.log(`❌ NO API MATCH found for Excel code: "${excelCode}"`);
                    }
                }
                
                // Priority 2: Partial code match
                if (!apiProduct && productCode) {
                    const codeStr = String(productCode);
                    apiProduct = bizimhesapProducts.find(p => 
                        (p.code && String(p.code).includes(codeStr)) ||
                        (p.sku && String(p.sku).includes(codeStr)) ||
                        (codeStr.includes(String(p.code)) && String(p.code).length > 3)
                    );
                    
                    if (apiProduct) {
                        console.log(`🔍 PARTIAL CODE MATCH: Excel code "${productCode}" ~ API code "${apiProduct.code}"`);
                    }
                }
                
                // Priority 3: Title matching (less reliable but still useful)
                if (!apiProduct && productName) {
                    // Try exact title match
                    apiProduct = bizimhesapProducts.find(p => 
                        p.title && p.title.toLowerCase() === productName.toLowerCase()
                    );
                    
                    // Try partial title match
                    if (!apiProduct) {
                        apiProduct = bizimhesapProducts.find(p => 
                            p.title && (
                                p.title.toLowerCase().includes(productName.toLowerCase()) ||
                                productName.toLowerCase().includes(p.title.toLowerCase())
                            )
                        );
                    }
                    
                    if (apiProduct) {
                        console.log(`📝 TITLE MATCH: Excel "${productName}" ~ API "${apiProduct.title}"`);
                    }
                }
                
                if (apiProduct && apiProduct.category) {
                    const category = apiProduct.category.toUpperCase();
                    console.log(`✅ API match found: ${apiProduct.title} → ${apiProduct.category}`);
                    
                    // Create main category mapping
                    const mainCategory = getMainCategory(apiProduct.category);
                    const productType = getBicycleOrAccessory(apiProduct.category);
                    
                    return { 
                        type: productType, 
                        category: apiProduct.category,
                        mainCategory: mainCategory,
                        source: 'api' 
                    };
                }
            }
            
            console.log(`⚠️ No API match, using name-based categorization`);
            // Fallback to name-based detection
            const result = categorizeByName(productName);
            result.source = 'name';
            result.mainCategory = getMainCategory(result.category);
            return result;
        }

        // Function to determine if product is bicycle or accessory by name
        function categorizeByName(productName) {
            if (!productName) return { type: 'accessory', category: 'UNCATEGORIZED' };
            
            const name = productName.toLowerCase();
            console.log(`🏷️ Name-based categorization for: "${name}"`);
            
            // Bicycle indicators (more comprehensive)
            const bicycleKeywords = [
                'bisiklet', 'bike', 'trek', 'fx', 'madone', 'domane', 'émonda', 'checkpoint',
                'verve', 'dual sport', 'marlin', 'x-caliber', 'fuel', 'remedy', 'slash',
                'session', 'supercaliber', 'top fuel', 'procaliber', 'roscoe', 'townie',
                'rail', 'powerfly', 'allant', 'distrito'
            ];
            
            // Accessory/spare part indicators (expanded)
            const accessoryKeywords = [
                'aksesuar', 'parça', 'pompa', 'kask', 'eldiven', 'çanta', 'ışık', 'kilit',
                'matara', 'saddle', 'sele', 'gidon', 'fren', 'vites', 'zincir', 'lastik',
                'jant', 'pedal', 'bagaj', 'mudguard', 'çamurluk', 'bontrager', 'servis',
                'helmet', 'glove', 'bottle', 'pump', 'tire', 'chain', 'brake', 'gear',
                'cable', 'grip', 'light', 'lock', 'bag', 'wheel', 'tube', 'pad',
                'hizmet', 'bakim', 'tamir', 'maintenance', 'service', 'repair'
            ];

            // Service/maintenance category
            const serviceKeywords = ['servis', 'hizmet', 'bakim', 'tamir', 'service', 'maintenance', 'repair', 'bike-fit'];
            
            // Check for service first
            if (serviceKeywords.some(keyword => name.includes(keyword))) {
                console.log(`✅ Categorized as SERVICE: ${productName}`);
                return { type: 'accessory', category: 'SERVİS' };
            }
            
            // Check for accessory (more specific)
            const foundAccessory = accessoryKeywords.find(keyword => name.includes(keyword));
            if (foundAccessory) {
                console.log(`✅ Categorized as ACCESSORY (${foundAccessory}): ${productName}`);
                return { type: 'accessory', category: 'AKSESUAR' };
            }
            
            // Then check for bicycle
            const foundBicycle = bicycleKeywords.find(keyword => name.includes(keyword));
            if (foundBicycle) {
                console.log(`✅ Categorized as BICYCLE (${foundBicycle}): ${productName}`);
                return { type: 'bicycle', category: 'BISIKLET' };
            }
            
            console.log(`⚠️ UNCATEGORIZED: "${productName}" (Code: ${typeof productCode !== 'undefined' ? productCode : 'undefined'}) - No matching keywords found`);
            console.log(`🔍 Checked sources: Local DB, Pattern matching, API matching, Name-based matching - ALL FAILED`);
            return { type: 'accessory', category: 'UNCATEGORIZED' };
        }
        
        // Exchange rates for currency conversion (2025 Jan-July averages from market data)
        const exchangeRates = {
            'TL': 1,
            'USD': 37.684, // 1 USD = 37.684 TL (2025 average)
            'EUR': 41.823  // 1 EUR = 41.823 TL (1.1096 EUR/USD * 37.684 USD/TL)
        };
        
        // Store distribution system for blank stores
        const storeDistributor = {
            targetStores: ['Alsancak', 'Bahçeköy', 'Ortaköy', 'Caddebostan'],
            distributionIndex: 0,
            
            distributeBlankStore: function(amount, quantity = 1) {
                // Get target store for this blank entry (round-robin)
                const targetStore = this.targetStores[this.distributionIndex];
                this.distributionIndex = (this.distributionIndex + 1) % this.targetStores.length;
                
                console.log(`📍 Distributing blank store: ${amount} TL → ${targetStore} (index: ${this.distributionIndex - 1})`);
                return targetStore;
            },
            
            resetDistribution: function() {
                this.distributionIndex = 0;
                console.log('🔄 Store distribution index reset');
            },
            
            getDistributionStats: function() {
                return {
                    stores: this.targetStores,
                    currentIndex: this.distributionIndex
                };
            }
        };

        // Currency conversion system
        const currencyConverter = {
            // Convert any amount to USD (base currency for totals)
            toUSD: function(amount, fromCurrency) {
                switch(fromCurrency.toUpperCase()) {
                    case 'USD': return amount;
                    case 'EUR': return amount * 1.1096; // EUR to USD average 2025
                    case 'TL': return amount / exchangeRates.USD; // TL to USD
                    default: return amount;
                }
            },
            
            // Convert any amount to any currency
            convert: function(amount, fromCurrency, toCurrency) {
                const usdAmount = this.toUSD(amount, fromCurrency);
                
                switch(toCurrency.toUpperCase()) {
                    case 'USD': return usdAmount;
                    case 'EUR': return usdAmount / 1.1096; // USD to EUR
                    case 'TL': return usdAmount * exchangeRates.USD; // USD to TL
                    default: return usdAmount;
                }
            },
            
            // Format currency with symbol
            format: function(amount, currency) {
                const symbols = { 'USD': '$', 'EUR': '€', 'TL': '₺' };
                const formatted = Math.abs(amount).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                return `${symbols[currency.toUpperCase()] || ''}${formatted}`;
            },
            
            // Get all currency totals for a given TL amount
            getAllTotals: function(tlAmount) {
                return {
                    TL: tlAmount,
                    USD: this.convert(tlAmount, 'TL', 'USD'),
                    EUR: this.convert(tlAmount, 'TL', 'EUR')
                };
            }
        };
        
        // Monthly exchange rate management
        const monthlyExchangeRates = {
            cache: new Map(), // Cache monthly average rates
            currentRates: {}, // Current active rates for this Excel file
            
            // Fetch monthly average USD/TRY rate for a specific month
            async fetchMonthlyUSDRate(year, month) {
                const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                
                if (this.cache.has(monthKey)) {
                    console.log(`💾 Using cached monthly USD rate for ${monthKey}: ${this.cache.get(monthKey)} TL`);
                    return this.cache.get(monthKey);
                }
                
                try {
                    // Fetch rates for first, mid, and last day of month to calculate average
                    const lastDay = new Date(year, month, 0).getDate();
                    const dates = [
                        `${year}-${month.toString().padStart(2, '0')}-01`,
                        `${year}-${month.toString().padStart(2, '0')}-15`,
                        `${year}-${month.toString().padStart(2, '0')}-${lastDay}`
                    ];
                    
                    const rates = [];
                    for (const date of dates) {
                        try {
                            const response = await fetch(`https://api.exchangerate-api.com/v4/historical/${date}/USD`);
                            if (response.ok) {
                                const data = await response.json();
                                if (data.rates?.TRY) {
                                    rates.push(data.rates.TRY);
                                }
                            }
                        } catch (e) {
                            console.warn(`⚠️ Could not fetch rate for ${date}:`, e.message);
                        }
                        
                        // Small delay to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    if (rates.length > 0) {
                        const averageRate = rates.reduce((sum, rate) => sum + rate, 0) / rates.length;
                        this.cache.set(monthKey, averageRate);
                        console.log(`💱 Calculated monthly average USD rate for ${monthKey}: ${averageRate.toFixed(3)} TL (from ${rates.length} data points)`);
                        return averageRate;
                    }
                    
                } catch (error) {
                    console.error(`💥 Error fetching monthly rate for ${monthKey}:`, error);
                }
                
                // Fallback to default rates if API fails
                const fallbackRates = {
                    '2025-01': 37.2, '2025-02': 37.5, '2025-03': 37.8, '2025-04': 38.1,
                    '2025-05': 38.4, '2025-06': 38.7, '2025-07': 39.0, '2025-08': 39.3,
                    '2025-09': 39.6, '2025-10': 39.9, '2025-11': 40.2, '2025-12': 40.5
                };
                
                const fallbackRate = fallbackRates[monthKey] || 37.684;
                console.log(`🔄 Using fallback USD rate for ${monthKey}: ${fallbackRate} TL`);
                this.cache.set(monthKey, fallbackRate);
                return fallbackRate;
            },
            
            // Process sales data with month-specific rates
            async processWithMonthlyRates(salesData) {
                console.log('🔄 Processing sales with monthly exchange rates...');
                
                // Group sales by month
                const salesByMonth = {};
                for (const sale of salesData) {
                    const saleDate = this.parseDate(sale.tarih);
                    if (saleDate) {
                        const monthKey = `${saleDate.getFullYear()}-${(saleDate.getMonth() + 1).toString().padStart(2, '0')}`;
                        if (!salesByMonth[monthKey]) {
                            salesByMonth[monthKey] = [];
                        }
                        salesByMonth[monthKey].push(sale);
                    }
                }
                
                // Fetch rates for each month and recalculate
                for (const [monthKey, monthlySales] of Object.entries(salesByMonth)) {
                    const [year, month] = monthKey.split('-').map(Number);
                    const monthlyUSDRate = await this.fetchMonthlyUSDRate(year, month);
                    const monthlyEURRate = monthlyUSDRate / 1.1096; // EUR rate based on USD
                    
                    console.log(`📊 Processing ${monthlySales.length} sales for ${monthKey} with USD rate: ${monthlyUSDRate.toFixed(3)} TL`);
                    
                    // Update each sale with correct monthly rate
                    for (const sale of monthlySales) {
                        const originalAmount = sale.toplam;
                        
                        // Recalculate amountInTL with correct monthly rate
                        if (sale.paraBirimi === 'EUR') {
                            sale.amountInTL = originalAmount * monthlyEURRate;
                        } else if (sale.paraBirimi === 'USD') {
                            sale.amountInTL = originalAmount * monthlyUSDRate;
                        }
                        // TL remains unchanged
                        
                        // Store the monthly rate used for this sale
                        sale.monthlyUSDRate = monthlyUSDRate;
                        sale.monthlyEURRate = monthlyEURRate;
                    }
                }
                
                return salesData;
            },
            
            parseDate(dateString) {
                if (!dateString) return null;
                
                const patterns = [
                    /(\d{2})\.(\d{2})\.(\d{4})/,  // 01.07.2025
                    /(\d{4})-(\d{2})-(\d{2})/,   // 2025-07-01
                    /(\d{2})\/(\d{2})\/(\d{4})/   // 01/07/2025
                ];
                
                for (const pattern of patterns) {
                    const match = dateString.match(pattern);
                    if (match) {
                        if (pattern === patterns[0] || pattern === patterns[2]) {
                            return new Date(parseInt(match[3]), parseInt(match[2]) - 1, parseInt(match[1]));
                        } else {
                            return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
                        }
                    }
                }
                
                return null;
            },
            
            // Update display with monthly rate information
            updateRateDisplay(salesData) {
                const exchangeRateInfo = document.getElementById('exchangeRatesInfo');
                if (!exchangeRateInfo) return;
                
                // Get unique months and their rates from sales data
                const monthlyRatesUsed = {};
                for (const sale of salesData) {
                    if (sale.monthlyUSDRate) {
                        const saleDate = this.parseDate(sale.tarih);
                        if (saleDate) {
                            const monthKey = `${saleDate.getFullYear()}-${(saleDate.getMonth() + 1).toString().padStart(2, '0')}`;
                            monthlyRatesUsed[monthKey] = sale.monthlyUSDRate;
                        }
                    }
                }
                
                const monthNames = {
                    '01': 'Ocak', '02': 'Şubat', '03': 'Mart', '04': 'Nisan',
                    '05': 'Mayıs', '06': 'Haziran', '07': 'Temmuz', '08': 'Ağustos',
                    '09': 'Eylül', '10': 'Ekim', '11': 'Kasım', '12': 'Aralık'
                };
                
                let rateInfo = '<strong>💱 Aylık Ortalama Döviz Kurları:</strong><br>';
                const sortedMonths = Object.entries(monthlyRatesUsed).sort();
                
                if (sortedMonths.length > 0) {
                    sortedMonths.forEach(([monthKey, rate]) => {
                        const [year, month] = monthKey.split('-');
                        const monthName = monthNames[month] || month;
                        rateInfo += `${monthName} ${year}: 1 USD = ₺${rate.toFixed(3)} | 1 EUR = ₺${(rate / 1.1096).toFixed(3)}<br>`;
                    });
                    rateInfo += '<div style="margin-top: 5px; font-size: 11px;"><em>Kaynak: Aylık ortalama API verisi (exchangerate-api.com)</em></div>';
                } else {
                    rateInfo += '2025 Genel Ortalaması: 1 USD = ₺37.684 | 1 EUR = ₺41.823<br>';
                    rateInfo += '<div style="margin-top: 5px; font-size: 11px;"><em>Kaynak: Yıllık ortalama verisi</em></div>';
                }
                
                exchangeRateInfo.innerHTML = rateInfo;
            }
        };

        // Dynamic exchange rate fetching (legacy - keeping for compatibility)
        const exchangeRateFetcher = {
            cache: new Map(), // Cache rates by date to avoid repeated API calls
            
            async fetchUSDRate(dateString) {
                try {
                    // Try to parse date from various formats
                    let targetDate = this.parseDate(dateString);
                    if (!targetDate) {
                        console.warn(`⚠️ Could not parse date: ${dateString}, using current rates`);
                        return null;
                    }
                    
                    const cacheKey = targetDate.toISOString().split('T')[0];
                    if (this.cache.has(cacheKey)) {
                        console.log(`💾 Using cached USD rate for ${cacheKey}`);
                        return this.cache.get(cacheKey);
                    }
                    
                    // Use exchangerate-api.com (free tier: 1500 requests/month)
                    const response = await fetch(`https://api.exchangerate-api.com/v4/latest/USD?date=${cacheKey}`);
                    
                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const usdToTry = data.rates?.TRY;
                    
                    if (usdToTry) {
                        this.cache.set(cacheKey, usdToTry);
                        console.log(`💱 Fetched USD rate for ${cacheKey}: 1 USD = ${usdToTry} TL`);
                        return usdToTry;
                    }
                    
                } catch (error) {
                    console.error('💥 Exchange rate fetch error:', error);
                }
                
                return null;
            },
            
            parseDate(dateString) {
                if (!dateString) return null;
                
                // Try various date formats
                const patterns = [
                    /(\d{2})\.(\d{2})\.(\d{4})/,  // 01.07.2025
                    /(\d{4})-(\d{2})-(\d{2})/,   // 2025-07-01
                    /(\d{2})\/(\d{2})\/(\d{4})/   // 01/07/2025
                ];
                
                for (const pattern of patterns) {
                    const match = dateString.match(pattern);
                    if (match) {
                        if (pattern === patterns[0] || pattern === patterns[2]) {
                            // DD.MM.YYYY or DD/MM/YYYY
                            return new Date(parseInt(match[3]), parseInt(match[2]) - 1, parseInt(match[1]));
                        } else {
                            // YYYY-MM-DD
                            return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
                        }
                    }
                }
                
                return null;
            },
            
            async updateRatesForPeriod(reportPeriod) {
                if (!reportPeriod || typeof reportPeriod !== 'string') return;
                
                console.log(`🔄 Fetching exchange rates for period: ${reportPeriod}`);
                
                // Extract date from report period (e.g., "01.07.2025 - 31.07.2025")
                const dateMatch = reportPeriod.match(/(\d{2})\.(\d{2})\.(\d{4})/);
                if (dateMatch) {
                    const midPeriodDate = `${dateMatch[1]}.${dateMatch[2]}.${dateMatch[3]}`;
                    const usdRate = await this.fetchUSDRate(midPeriodDate);
                    
                    if (usdRate && usdRate !== exchangeRates.USD) {
                        // Update exchange rates for this session
                        exchangeRates.USD = usdRate;
                        exchangeRates.EUR = usdRate / 1.1096; // Adjust EUR rate proportionally
                        
                        // Update the display
                        const exchangeRateInfo = document.getElementById('exchangeRatesInfo');
                        if (exchangeRateInfo) {
                            exchangeRateInfo.innerHTML = `
                                <strong>💱 Döviz Kurları (${reportPeriod} Dönemi):</strong><br>
                                1 USD = ₺${exchangeRates.USD.toFixed(3)} | 1 EUR = ₺${exchangeRates.EUR.toFixed(3)} | EUR/USD = ${(1.1096).toFixed(4)}
                                <div style="margin-top: 5px; font-size: 11px;">
                                    <em>Kaynak: Anlık API verisi (exchangerate-api.com)</em>
                                </div>
                            `;
                        }
                        
                        console.log(`✅ Updated USD rate: ${usdRate} TL (from API)`);
                        return usdRate;
                    }
                }
                
                return null;
            }
        };

        // File input handling
        console.log('🔧 Setting up event listeners...');
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            fileInput.addEventListener('change', handleFileSelect);
            console.log('✅ File input listener added');
        } else {
            console.error('❌ File input element not found!');
        }
        
        // Drag and drop handling
        const uploadArea = document.querySelector('.upload-area');
        if (uploadArea) {
            console.log('✅ Upload area found');
        } else {
            console.error('❌ Upload area not found!');
        }
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, unhighlight, false);
        });

        function highlight(e) {
            uploadArea.classList.add('dragover');
        }

        function unhighlight(e) {
            uploadArea.classList.remove('dragover');
        }

        uploadArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            handleFiles(files);
        }

        function handleFiles(files) {
            console.log('📂 handleFiles called with:', files.length, 'files');
            
            if (files.length === 0) {
                console.log('❌ No files provided');
                return;
            }
            
            const file = files[0];
            console.log('📁 Selected file:', file.name, file.size, 'bytes');
            
            // Validate file type
            if (!file.name.toLowerCase().match(/\.(xlsx|xls)$/)) {
                console.log('❌ Invalid file type:', file.name);
                showError('Lütfen .xlsx veya .xls formatında bir Excel dosyası seçin.');
                return;
            }

            // Show file info
            document.getElementById('fileInfo').innerHTML = `
                📁 <strong>${file.name}</strong> (${formatFileSize(file.size)}) - ${new Date(file.lastModified).toLocaleString('tr-TR')}
            `;
            document.getElementById('fileInfo').style.display = 'block';

            console.log('✅ Valid Excel file, starting processing...');
            
            // Process file
            processExcelFile(file);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        async function processExcelFile(file) {
            console.clear(); // Clear previous logs
            console.log('🚀 STARTING EXCEL PROCESSING...');
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('analysisSection').style.display = 'none';

            // Load BizimHesap products first
            await loadBizimHesapProducts();

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const buffer = e.target.result;
                    const workbook = new ExcelJS.Workbook();
                    await workbook.xlsx.load(buffer);
                    
                    const worksheet = workbook.getWorksheet(1);
                    console.log('📊 Worksheet dimensions:', worksheet.dimensions);
                    console.log('🔗 Merged cells:', worksheet.model.merges);
                    
                    // Convert ExcelJS data to array format for compatibility (0-based indexing)
                    const jsonData = [];
                    const maxRow = worksheet.rowCount;
                    const maxCol = 12; // A-L columns
                    
                    for (let i = 1; i <= maxRow; i++) {
                        const row = worksheet.getRow(i);
                        const rowData = [];
                        
                        for (let j = 1; j <= maxCol; j++) {
                            const cell = row.getCell(j);
                            let value = cell.value;
                            
                            // Handle merged cells - get master value
                            if (cell.isMerged && cell.master) {
                                value = cell.master.value;
                            }
                            
                            // Convert value to string/number as needed
                            if (value !== null && value !== undefined) {
                                if (typeof value === 'object' && value.result) {
                                    value = value.result; // Handle formulas
                                } else if (typeof value === 'object' && value.text) {
                                    value = value.text; // Handle rich text
                                }
                            }
                            
                            // Convert to 0-based array index (j-1)
                            rowData[j-1] = value || '';
                        }
                        
                        // Convert to 0-based array index (i-1)
                        jsonData[i-1] = rowData;
                    }
                    
                    console.log('📊 ExcelJS processed jsonData - First 10 rows:', jsonData.slice(0, 10));
                    
                    // Process data with initial exchange rates
                    currentData = processData(jsonData);
                    
                    // Apply monthly-specific exchange rates for precise calculations
                    if (currentData.sales && currentData.sales.length > 0) {
                        await monthlyExchangeRates.processWithMonthlyRates(currentData.sales);
                        
                        // Recalculate all totals with monthly rates
                        currentData = recalculateWithMonthlyRates(currentData);
                        
                        // Update rate display
                        monthlyExchangeRates.updateRateDisplay(currentData.sales);
                    }
                    
                    // Add to memory
                    excelMemory.addFile(file.name, currentData, file.size);
                    
                    // Show memory status
                    document.getElementById('memoryStatus').style.display = 'block';
                    
                    // Show exchange rates info
                    document.getElementById('exchangeRatesInfo').style.display = 'block';
                    
                    // Display results
                    displayAnalysis();
                    
                } catch (error) {
                    console.error('Excel processing error:', error);
                    showError('Excel dosyası işlenirken hata oluştu: ' + error.message);
                } finally {
                    document.getElementById('loading').style.display = 'none';
                }
            };
            
            reader.readAsArrayBuffer(file);
        }

        function processData(jsonData) {
            if (jsonData.length < 3) {
                throw new Error('Excel dosyasında yeterli veri bulunamadı');
            }

            // Find header row - Based on Excel analysis:
            // Row 0: "SATIŞ RAPORU"
            // Row 1: Date range "01.07.2025 - 31.07.2025"
            // Row 2: Headers "Belge No", "Tarih", "Depo", etc.
            // Row 3+: Data
            
            let headerRowIndex = 2; // Headers are in row 2 based on Excel analysis
            let dateRowIndex = 1;   // Row 1 contains the date range
            
            // Verify by checking if row 2 contains typical headers
            if (jsonData.length > 2) {
                const potentialHeaderRow = jsonData[2];
                if (potentialHeaderRow && potentialHeaderRow.length > 5) {
                    const headerText = potentialHeaderRow.join(' ').toLowerCase();
                    if (headerText.includes('belge') || headerText.includes('tarih') || 
                        headerText.includes('depo') || headerText.includes('müşteri')) {
                        console.log('✅ Header row confirmed at index 2');
                    } else {
                        console.log('⚠️ Expected headers not found at row 2, using default');
                    }
                }
            }
            
            console.log('📍 Selected headerRowIndex:', headerRowIndex);
            console.log('📍 Raw header row:', jsonData[headerRowIndex]);

            const headers = jsonData[headerRowIndex];
            // Data starts after the header row (row 3+ in 0-based indexing)
            const dataRows = jsonData.slice(headerRowIndex + 1); // Skip title, date and headers
            
            console.log('📊 Total data rows to process:', dataRows.length);
            console.log('📋 First 3 data rows:', dataRows.slice(0, 3));

            // Map column indices based on Excel analysis
            // Excel structure: Row 0 = Date, Row 1 = Headers, Row 2+ = Data
            // Headers: "Belge No", "Tarih", "Depo", "Müşteri", "Şube", "Ürün", "Kod", "Miktar", "Birim", "Net", "TOPLAM", Currency
            const columnMap = {
                belgeNo: 0,    // Column A: "SATIŞ RAPORU" / "Belge No" 
                tarih: 1,      // Column B: "Unnamed: 1" / "Tarih" 
                depo: 2,       // Column C: "Unnamed: 2" / "Depo"
                musteri: 3,    // Column D: "Unnamed: 3" / "Müşteri"  
                sube: 4,       // Column E: "Unnamed: 4" / "Şube"
                urun: 5,       // Column F: "Unnamed: 5" / "Ürün"
                kod: 6,        // Column G: "Unnamed: 6" / "Kod"
                miktar: 7,     // Column H: "Unnamed: 7" / "Miktar"
                birim: 8,      // Column I: "Unnamed: 8" / "Birim"
                net: 9,        // Column J: "Unnamed: 9" / "Net"
                toplam: 10,    // Column K: "Unnamed: 10" / "TOPLAM"
                paraBirimi: 11 // Column L: "Unnamed: 11" / Currency (TL/EUR/USD)
            };

            // Try to find actual column indices if headers are available
            if (headers && headers.length > 5) {
                console.log('🔍 Trying to map headers:', headers);
                for (let i = 0; i < headers.length; i++) {
                    const header = String(headers[i] || '').toLowerCase();
                    console.log(`Header ${i}: "${headers[i]}" -> "${header}"`);
                    if (header.includes('belge')) columnMap.belgeNo = i;
                    else if (header.includes('tarih')) columnMap.tarih = i;
                    else if (header.includes('depo')) columnMap.depo = i;
                    else if (header.includes('müşteri') || header.includes('musteri')) columnMap.musteri = i;
                    else if (header.includes('şube') || header.includes('sube')) columnMap.sube = i;
                    else if (header.includes('ürün') || header.includes('urun')) columnMap.urun = i;
                    else if (header.includes('kod')) columnMap.kod = i;
                    else if (header.includes('miktar')) columnMap.miktar = i;
                    else if (header.includes('birim')) columnMap.birim = i;
                    else if (header.includes('net')) columnMap.net = i;
                    else if (header.includes('toplam')) columnMap.toplam = i;
                }
                console.log('🎯 Final Column Map after header parsing:', columnMap);
            } else {
                console.log('❌ Headers not available or too short, using default mapping');
            }

            const sales = [];
            const stores = {};
            const dealers = {};
            const customers = new Set();
            const categories = {}; // Track sales by category
            const uncategorizedItems = []; // Track uncategorized items
            let totalAmount = 0;
            let totalQuantity = 0;
            let bicycleSales = 0;
            let accessorySales = 0;
            let bicycleQuantity = 0;
            let accessoryQuantity = 0;
            let reportPeriod = '';
            let dealerCount = 0;
            let storeCount = 0;
            
            // Find report period from date row (row 1)
            if (jsonData.length > 1 && jsonData[dateRowIndex] && jsonData[dateRowIndex][0]) {
                const dateCell = String(jsonData[dateRowIndex][0]);
                if (dateCell.includes('-') && dateCell.includes('2025')) {
                    reportPeriod = dateCell;
                    console.log('📅 Report period found:', reportPeriod);
                }
            }
            
            // Fallback: check first row if not found in date row
            if (!reportPeriod && jsonData.length > 0 && jsonData[0][0]) {
                const firstCell = String(jsonData[0][0]);
                if (firstCell.includes('-')) {
                    reportPeriod = firstCell;
                    console.log('📅 Report period from first row:', reportPeriod);
                }
            }
            
            // Define dealer detection patterns - more comprehensive matching
            const dealerPatterns = [
                { 
                    names: ['ercem akcan', 'ercem', 'akcan'],
                    dealer: 'Ercem Akcan',
                    getCurrency: (paraBirimi) => paraBirimi || 'TL',
                    getType: (paraBirimi) => paraBirimi === 'EUR' ? 'EUR' : paraBirimi === 'USD' ? 'USD' : 'SC Bisiklet'
                },
                {
                    names: ['mert bikestop', 'mert', 'bikestop', 'bıke stop', 'bike stop', 'dalkılıç', 'mert dalkılıç', 'bıke stop (mert dalkılıç)', 'bike stop (mert dalkılıç)'],
                    dealer: 'Mert Bikestop', 
                    getCurrency: (paraBirimi) => paraBirimi || 'TL',
                    getType: (paraBirimi) => paraBirimi || 'TL'
                }
            ];


            // Process each row
            console.log('🔄 Processing rows:', dataRows.length);
            console.log('📋 Column Map:', columnMap);
            console.log('📋 Headers:', headers);
            console.log('📊 Sample dataRows[0-2]:', dataRows.slice(0, 3));
            console.log('🔍 First data row details:', dataRows[0]);
            console.log('🔍 Second data row details:', dataRows[1]);
            console.log('🔍 Third data row details:', dataRows[2]);
            
            // Reset store distribution for this Excel file
            storeDistributor.resetDistribution();
            
            let lastValidCustomer = ''; // Track last valid customer for merged cells
            let lastValidStore = ''; // Track last valid store for merged cells
            let lastValidProduct = ''; // Track last valid product for merged cells
            
            for (let i = 0; i < dataRows.length; i++) {
                const row = dataRows[i];
                if (!row || row.length < 10) {
                    if (i < 5) console.log(`⏭️ Skipping row ${i}:`, row);
                    continue;
                }
                
                let depo = String(row[columnMap.depo] || '').trim();
                let musteri = String(row[columnMap.musteri] || '').trim();
                const toplam = parseFloat(String(row[columnMap.toplam] || '').replace(',', '.')) || 0;
                const miktar = parseInt(String(row[columnMap.miktar] || '').replace(',', '.')) || 0;
                let urun = String(row[columnMap.urun] || '').trim();
                let paraBirimi = String(row[columnMap.paraBirimi] || 'TL').trim().toUpperCase();
                const tarih = row[columnMap.tarih];
                
                // Clean and normalize currency values
                if (!paraBirimi || paraBirimi === 'NAN' || paraBirimi === '') {
                    paraBirimi = 'TL'; // Default to TL
                }
                
                // Handle common currency variations
                if (paraBirimi.includes('EUR')) paraBirimi = 'EUR';
                else if (paraBirimi.includes('USD') || paraBirimi.includes('DOLAR')) paraBirimi = 'USD';
                else paraBirimi = 'TL';

                // Enhanced merged cell handling - look backward for valid values
                if (!musteri || musteri.trim() === '' || musteri === 'NaN') {
                    // Look backward in recent rows to find the actual customer
                    if (lastValidCustomer) {
                        musteri = lastValidCustomer;
                    } else {
                        // Search backwards up to 10 rows for customer name
                        for (let backSearch = Math.max(0, i - 10); backSearch < i; backSearch++) {
                            const searchRow = dataRows[backSearch];
                            if (searchRow && searchRow[columnMap.musteri]) {
                                const searchCustomer = String(searchRow[columnMap.musteri]).trim();
                                if (searchCustomer && searchCustomer !== 'NaN' && searchCustomer.length > 2) {
                                    musteri = searchCustomer;
                                    lastValidCustomer = searchCustomer;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    // Update last valid customer
                    lastValidCustomer = musteri;
                }

                if (!depo || depo.trim() === '' || depo === 'NaN') {
                    // Look backward in recent rows to find the actual store
                    if (lastValidStore) {
                        depo = lastValidStore;
                    } else {
                        // Search backwards up to 10 rows for store name
                        for (let backSearch = Math.max(0, i - 10); backSearch < i; backSearch++) {
                            const searchRow = dataRows[backSearch];
                            if (searchRow && searchRow[columnMap.depo]) {
                                const searchStore = String(searchRow[columnMap.depo]).trim();
                                if (searchStore && searchStore !== 'NaN' && searchStore.length > 2) {
                                    depo = searchStore;
                                    lastValidStore = searchStore;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    // Update last valid store
                    lastValidStore = depo;
                }

                // Enhanced product name handling
                if (!urun || urun.trim() === '' || urun === 'NaN') {
                    // Look backward in recent rows to find the actual product name
                    if (lastValidProduct) {
                        urun = lastValidProduct;
                    } else {
                        // Search backwards up to 10 rows for product name
                        for (let backSearch = Math.max(0, i - 10); backSearch < i; backSearch++) {
                            const searchRow = dataRows[backSearch];
                            if (searchRow && searchRow[columnMap.urun]) {
                                const searchProduct = String(searchRow[columnMap.urun]).trim();
                                if (searchProduct && searchProduct !== 'NaN' && searchProduct.length > 2) {
                                    urun = searchProduct;
                                    lastValidProduct = searchProduct;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    // Update last valid product
                    lastValidProduct = urun;
                }

                if (i < 10) {
                    console.log(`📊 Row ${i} data:`, {
                        raw_depo: row[columnMap.depo],
                        raw_musteri: row[columnMap.musteri], 
                        raw_toplam: row[columnMap.toplam],
                        raw_paraBirimi: row[columnMap.paraBirimi],
                        raw_urun: row[columnMap.urun],
                        raw_full_row: row,
                        columnMap: columnMap,
                        processed: { depo, musteri, toplam, miktar, urun, paraBirimi, tarih },
                        merged_cell_tracking: {
                            lastValidCustomer,
                            lastValidStore,
                            lastValidProduct
                        }
                    });
                }

                // Skip invalid rows - Only check TOPLAM for now, ignore empty customer names
                if (!toplam || toplam <= 0) {
                    if (i < 10) console.log(`❌ Skipping invalid row ${i}:`, { toplam });
                    continue;
                }

                // Use fallback customer name if empty
                if (!musteri || musteri.trim() === '') {
                    musteri = 'Unknown Customer';
                }

                // Handle blank stores - distribute equally to target stores
                if (!depo || depo.trim() === '' || depo === 'Unknown Store') {
                    depo = storeDistributor.distributeBlankStore(amountInTL, miktar);
                }

                if (i < 5) console.log(`✅ Processing valid row ${i}:`, { musteri, depo, toplam, miktar });

                // Convert to TL if needed (will be recalculated with monthly rates later)
                let amountInTL = toplam;
                if (paraBirimi === 'EUR') {
                    amountInTL = toplam * exchangeRates.EUR;
                } else if (paraBirimi === 'USD') {
                    amountInTL = toplam * exchangeRates.USD;
                }

                // Add to totals
                totalAmount += amountInTL;
                totalQuantity += miktar;

                // Categorize using enhanced method with BizimHesap API
                const productKod = row[columnMap.kod] || '';
                const categoryInfo = categorizeProduct(productKod, urun);
                
                // Track category-specific sales using main categories
                const mainCategoryName = categoryInfo.mainCategory || categoryInfo.category || 'UNCATEGORIZED';
                
                // Track uncategorized items for debugging
                if (mainCategoryName === 'UNCATEGORIZED') {
                    uncategorizedItems.push({
                        product: urun,
                        code: productKod,
                        amount: amountInTL,
                        quantity: miktar,
                        store: depo,
                        customer: musteri
                    });
                }
                
                if (!categories[mainCategoryName]) {
                    categories[mainCategoryName] = {
                        name: mainCategoryName,
                        originalCategory: categoryInfo.category,
                        type: categoryInfo.type,
                        totalTL: 0,
                        quantity: 0,
                        products: new Set(),
                        source: categoryInfo.source || 'unknown',
                        subcategories: new Set()
                    };
                }
                categories[mainCategoryName].totalTL += amountInTL;
                categories[mainCategoryName].quantity += miktar;
                categories[mainCategoryName].products.add(urun);
                if (categoryInfo.category) {
                    categories[mainCategoryName].subcategories.add(categoryInfo.category);
                }
                
                if (categoryInfo.type === 'bicycle') {
                    bicycleSales += amountInTL;
                    bicycleQuantity += miktar;
                } else {
                    accessorySales += amountInTL;
                    accessoryQuantity += miktar;
                }

                if (i < 15) { // More debug for first 15 items  
                    console.log(`🏷️ Row ${i}: "${urun}" (Code: ${productKod}) → ${categoryInfo.type.toUpperCase()} | Main: ${mainCategoryName} | Sub: ${categoryInfo.category} [${categoryInfo.source}] | ₺${amountInTL.toLocaleString()} | ${miktar} adet`);
                }

                sales.push({
                    belgeNo: row[columnMap.belgeNo],
                    tarih: tarih,
                    depo: depo, // Use processed depo, not raw
                    musteri: musteri, // Use processed musteri, not raw
                    urun: urun, // Use processed urun, not raw
                    miktar: miktar, // Use processed miktar
                    net: parseFloat(row[columnMap.net]) || 0,
                    toplam: toplam, // Original amount in original currency
                    paraBirimi: paraBirimi,
                    amountInTL: amountInTL // Will be recalculated with monthly rates
                });

                // Check if this is a dealer transaction using improved pattern matching
                const customerLower = musteri.toLowerCase().trim();
                let isDealer = false;
                let matchedDealer = null;
                
                if (i < 10) {
                    console.log(`🤝 Checking dealer patterns for customer: "${musteri}" → "${customerLower}"`);
                }
                
                for (const pattern of dealerPatterns) {
                    // Check if any of the dealer names match
                    const matchedName = pattern.names.find(name => customerLower.includes(name.toLowerCase()));
                    if (matchedName) {
                        isDealer = true;
                        matchedDealer = pattern;
                        
                        if (i < 10) {
                            console.log(`✅ DEALER MATCH: "${musteri}" matched with pattern "${matchedName}" → ${pattern.dealer}`);
                        }
                        
                        const dealerType = pattern.getType(paraBirimi);
                        const dealerCurrency = pattern.getCurrency(paraBirimi);
                        const dealerKey = `${pattern.dealer} (${dealerType})`;
                        
                        if (!dealers[dealerKey]) {
                            dealers[dealerKey] = {
                                name: pattern.dealer,
                                type: dealerType,
                                currency: dealerCurrency,
                                totalTL: 0,
                                orderCount: 0,
                                customers: new Set()
                            };
                        }
                        
                        dealers[dealerKey].totalTL += amountInTL;
                        dealers[dealerKey].orderCount += 1;
                        dealers[dealerKey].customers.add(musteri);
                        
                        console.log(`🤝 DEALER: ${musteri} → ${dealerKey} (${paraBirimi}, ₺${amountInTL.toLocaleString()})`);
                        dealerCount++;
                        break;
                    }
                }
                
                // Only aggregate by store if not a dealer
                if (!isDealer) {
                    const storeName = depo || 'Bilinmeyen';
                    if (!stores[storeName]) {
                        stores[storeName] = {
                            name: storeName,
                            totalTL: 0,
                            orderCount: 0,
                            customers: new Set()
                        };
                    }

                    stores[storeName].totalTL += amountInTL;
                    stores[storeName].orderCount += 1;
                    stores[storeName].customers.add(musteri);
                    
                    console.log(`🏪 STORE: ${storeName} | ${musteri} | ₺${amountInTL.toLocaleString()}`);
                    storeCount++;
                }

                customers.add(musteri);
            }

            // Convert Set to Array for categories products and subcategories
            Object.values(categories).forEach(category => {
                category.products = Array.from(category.products);
                category.subcategories = Array.from(category.subcategories || []);
            });

            // Log category summary
            console.log('\n📊 MAIN CATEGORY ANALYSIS SUMMARY:');
            Object.values(categories)
                .sort((a, b) => b.totalTL - a.totalTL)
                .forEach(cat => {
                    const subCatList = cat.subcategories.length > 0 ? ` (Alt: ${cat.subcategories.join(', ')})` : '';
                    console.log(`  ${cat.name} [${cat.source}]: ₺${cat.totalTL.toLocaleString('tr-TR')} | ${cat.quantity} adet | ${cat.products.length} çeşit${subCatList}`);
                });

            // Log detailed uncategorized items
            if (uncategorizedItems.length > 0) {
                console.log('\n⚠️ UNCATEGORIZED ITEMS DETAILED:');
                uncategorizedItems.forEach((item, index) => {
                    console.log(`  ${index + 1}. "${item.product}" (Code: ${item.code || 'NO CODE'}) | ₺${item.amount.toLocaleString()} | ${item.quantity} adet | Store: ${item.store || 'Unknown'} | Customer: ${item.customer}`);
                });
                console.log(`\n⚠️ Total UNCATEGORIZED: ${uncategorizedItems.length} items, ₺${uncategorizedItems.reduce((sum, item) => sum + item.amount, 0).toLocaleString()}`);
            }

            console.log(`\n🏪 STORE vs DEALER COUNT: Stores: ${storeCount} transactions | Dealers: ${dealerCount} transactions`);

            const processedData = {
                sales: sales,
                stores: stores,
                dealers: dealers,
                categories: categories,
                totalAmount: totalAmount,
                totalQuantity: totalQuantity,
                bicycleSales: bicycleSales,
                accessorySales: accessorySales,
                bicycleQuantity: bicycleQuantity,
                accessoryQuantity: accessoryQuantity,
                customerCount: customers.size,
                orderCount: sales.length,
                reportPeriod: reportPeriod
            };

            // Add to monthly history for trend analysis
            if (reportPeriod) {
                // Check if this month already exists in history
                const existingIndex = monthlyDataHistory.findIndex(item => item.reportPeriod === reportPeriod);
                if (existingIndex >= 0) {
                    monthlyDataHistory[existingIndex] = processedData; // Update existing
                } else {
                    monthlyDataHistory.push(processedData); // Add new
                }
                console.log(`📈 Monthly history updated. Total months: ${monthlyDataHistory.length}`);
            }

            // Apply monthly exchange rates to sales data
            console.log('🔄 Starting monthly exchange rate processing...');
            
            return processedData;
        }

        function recalculateWithMonthlyRates(data) {
            console.log('🔄 Recalculating totals with monthly exchange rates...');
            
            // Reset totals
            let newTotalAmount = 0;
            let newCategorySales = {};
            let newStoreSales = {};
            let newDealerSales = {};
            let newBicycleSales = 0;
            let newAccessorySales = 0;
            
            // Recalculate everything with updated amountInTL values
            for (const sale of data.sales) {
                newTotalAmount += sale.amountInTL;
                
                // Recalculate category sales
                const categoryInfo = categorizeProduct(sale.kod || '', sale.urun || '');
                const mainCategoryName = categoryInfo.mainCategory || categoryInfo.category || 'UNCATEGORIZED';
                newCategorySales[mainCategoryName] = (newCategorySales[mainCategoryName] || 0) + sale.amountInTL;
                
                // Recalculate store sales
                newStoreSales[sale.depo] = (newStoreSales[sale.depo] || 0) + sale.amountInTL;
                
                // Recalculate dealer sales
                const customerLower = sale.musteri.toLowerCase().trim();
                let isDealer = false;
                
                if (customerLower.includes('ercem') || customerLower.includes('akcan')) {
                    newDealerSales['Ercem Akcan'] = (newDealerSales['Ercem Akcan'] || 0) + sale.amountInTL;
                    isDealer = true;
                } else if (customerLower.includes('mert') || customerLower.includes('bikestop') || customerLower.includes('bıke stop')) {
                    newDealerSales['Mert Bikestop'] = (newDealerSales['Mert Bikestop'] || 0) + sale.amountInTL;
                    isDealer = true;
                }
                
                // Recalculate bicycle vs accessory sales
                if (categoryInfo.type === 'bicycle') {
                    newBicycleSales += sale.amountInTL;
                } else {
                    newAccessorySales += sale.amountInTL;
                }
            }
            
            // Update the data object
            data.totalAmount = newTotalAmount;
            data.categorySales = newCategorySales;
            data.storeSales = newStoreSales;
            data.dealerSales = newDealerSales;
            data.bicycleSales = newBicycleSales;
            data.accessorySales = newAccessorySales;
            
            console.log(`✅ Recalculated totals: ₺${newTotalAmount.toLocaleString()}`);
            return data;
        }

        function showYearlyAnalysis() {
            const allData = excelMemory.getAllData();
            
            if (allData.files.length < 2) {
                alert('Yıllık analiz için en az 2 aylık veri gerekli. Lütfen daha fazla Excel dosyası yükleyin.');
                return;
            }
            
            // Show yearly analysis
            showYearlyReport(allData);
        }

        function showYearlyReport(allData) {
            // Hide current analysis
            document.getElementById('analysisSection').style.display = 'none';
            
            // Create yearly analysis container if not exists
            let yearlyContainer = document.getElementById('yearlyAnalysis');
            if (!yearlyContainer) {
                yearlyContainer = document.createElement('div');
                yearlyContainer.id = 'yearlyAnalysis';
                yearlyContainer.className = 'section';
                document.querySelector('.container').appendChild(yearlyContainer);
            }
            
            // Sort monthly data
            const sortedMonths = Object.entries(allData.monthlyBreakdown)
                .sort((a, b) => a[0].localeCompare(b[0]));
            
            // Sort categories by sales
            const topCategories = Object.entries(allData.categories)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const monthNames = {
                '01': 'Ocak', '02': 'Şubat', '03': 'Mart', '04': 'Nisan',
                '05': 'Mayıs', '06': 'Haziran', '07': 'Temmuz', '08': 'Ağustos',
                '09': 'Eylül', '10': 'Ekim', '11': 'Kasım', '12': 'Aralık'
            };
            
            yearlyContainer.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>📅 2025 Yıllık Satış Analizi</h2>
                    <button onclick="document.getElementById('yearlyAnalysis').style.display='none'; document.getElementById('analysisSection').style.display='block';" class="section-btn">← Geri Dön</button>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div style="background: #e8f5e8; padding: 20px; border-radius: 8px; text-align: center;">
                        <h3>💰 Toplam Satış (Tüm Para Birimleri)</h3>
                        <div style="font-size: 24px; font-weight: bold; color: #27ae60;">${formatCurrency(allData.totalSales, 'TL')}</div>
                        <div style="font-size: 14px; margin-top: 8px; color: #666;">
                            🇺🇸 ${currencyConverter.format(currencyConverter.convert(allData.totalSales, 'TL', 'USD'), 'USD')} |
                            🇪🇺 ${currencyConverter.format(currencyConverter.convert(allData.totalSales, 'TL', 'EUR'), 'EUR')}
                        </div>
                        <div style="color: #666; margin-top: 5px;">${allData.files.length} aylık veri</div>
                    </div>
                    
                    <div style="background: #e8f4f8; padding: 20px; border-radius: 8px; text-align: center;">
                        <h3>📦 Toplam Ürün</h3>
                        <div style="font-size: 24px; font-weight: bold; color: #3498db;">${allData.totalQuantity.toLocaleString()} adet</div>
                        <div style="color: #666;">Tüm kategoriler</div>
                    </div>
                    
                    <div style="background: #fef9e7; padding: 20px; border-radius: 8px; text-align: center;">
                        <h3>📈 Ortalama Aylık</h3>
                        <div style="font-size: 24px; font-weight: bold; color: #f39c12;">${formatCurrency(allData.totalSales / allData.files.length, 'TL')}</div>
                        <div style="font-size: 12px; color: #666;">
                            ${currencyConverter.format(currencyConverter.convert(allData.totalSales / allData.files.length, 'TL', 'USD'), 'USD')} |
                            ${currencyConverter.format(currencyConverter.convert(allData.totalSales / allData.files.length, 'TL', 'EUR'), 'EUR')}
                        </div>
                        <div style="color: #666; margin-top: 3px;">Aylık ortalama</div>
                    </div>
                </div>
                
                <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h3>📊 Aylık Satış Dağılımı</h3>
                    ${sortedMonths.map(([month, amount]) => {
                        const monthName = monthNames[month.split('-')[1]] || month;
                        const percentage = (amount / allData.totalSales * 100).toFixed(1);
                        return `
                            <div style="display: flex; align-items: center; margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 6px;">
                                <div style="min-width: 80px; font-weight: 600;">${monthName}:</div>
                                <div style="flex: 1; background: #e9ecef; height: 25px; border-radius: 12px; margin: 0 15px; position: relative; overflow: hidden;">
                                    <div style="width: ${percentage}%; background: linear-gradient(90deg, #3498db, #2ecc71); height: 100%; border-radius: 12px;"></div>
                                    <span style="position: absolute; top: 50%; left: 10px; transform: translateY(-50%); font-size: 12px; font-weight: 600; color: white;">${formatCurrency(amount, 'TL')} (${percentage}%)</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h3>🏆 En İyi Satan Kategoriler (Yıllık)</h3>
                    ${topCategories.map(([category, amount], index) => {
                        const percentage = (amount / allData.totalSales * 100).toFixed(1);
                        const medal = index === 0 ? '🥇' : index === 1 ? '🥈' : index === 2 ? '🥉' : `${index + 1}.`;
                        return `
                            <div style="display: flex; align-items: center; padding: 12px; margin: 8px 0; background: ${index < 3 ? '#fff3cd' : '#f8f9fa'}; border-radius: 6px; border: 1px solid ${index < 3 ? '#ffeaa7' : '#e9ecef'};">
                                <span style="font-size: 20px; margin-right: 15px;">${medal}</span>
                                <span style="flex: 1; font-weight: 600;">${category}</span>
                                <span style="font-weight: bold; color: #27ae60;">${formatCurrency(amount, 'TL')} (${percentage}%)</span>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h4>📚 Analiz Edilen Dosyalar</h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px;">
                        ${allData.files.map(file => `<span style="background: #3498db; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">${file}</span>`).join('')}
                    </div>
                </div>
            `;
            
            yearlyContainer.style.display = 'block';
        }

        function displayAnalysis() {
            if (!currentData) return;

            // Show analysis section
            document.getElementById('analysisSection').style.display = 'block';

            // Update currency display
            updateCurrencyDisplay();
        }

        function updateCurrencyDisplay() {
            if (!currentData) {
                console.log('❌ No currentData available');
                return;
            }

            console.log('📊 Current Data:', currentData);
            
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? '₺' : currentCurrency === 'USD' ? '$' : '€';

            // Update report period
            const periodElement = document.getElementById('periodInfo');
            if (periodElement) {
                periodElement.textContent = `📅 Rapor Dönemi: ${currentData.reportPeriod || 'Belirtilmemiş'}`;
            }

            // Update all statistics with currency conversion
            const totalSalesEl = document.getElementById('totalSales');
            if (totalSalesEl && typeof currentData.totalAmount === 'number') {
                // Show current selected currency as main value
                totalSalesEl.textContent = symbol + (currentData.totalAmount / rate).toLocaleString('tr-TR', { maximumFractionDigits: 0 });
                
                // Update all currency totals
                const allTotals = currencyConverter.getAllTotals(currentData.totalAmount);
                document.getElementById('totalUSD').textContent = currencyConverter.format(allTotals.USD, 'USD');
                document.getElementById('totalEUR').textContent = currencyConverter.format(allTotals.EUR, 'EUR');
                document.getElementById('totalTL').textContent = currencyConverter.format(allTotals.TL, 'TL');
                
                console.log('✅ Total Sales Updated:', totalSalesEl.textContent);
                console.log('💱 Currency Breakdown:', allTotals);
                
                // Show store distribution stats
                const distStats = storeDistributor.getDistributionStats();
                console.log('📍 Store Distribution Stats:', distStats);
            }

            const totalQuantityEl = document.getElementById('totalQuantity');
            if (totalQuantityEl && typeof currentData.totalQuantity === 'number') {
                totalQuantityEl.textContent = currentData.totalQuantity.toLocaleString('tr-TR') + ' adet';
                console.log('✅ Total Quantity Updated:', totalQuantityEl.textContent);
            }

            const bicycleSalesEl = document.getElementById('bicycleSales');
            if (bicycleSalesEl && typeof currentData.bicycleSales === 'number') {
                bicycleSalesEl.textContent = symbol + (currentData.bicycleSales / rate).toLocaleString('tr-TR', { maximumFractionDigits: 0 });
            }

            const accessorySalesEl = document.getElementById('accessorySales');
            if (accessorySalesEl && typeof currentData.accessorySales === 'number') {
                accessorySalesEl.textContent = symbol + (currentData.accessorySales / rate).toLocaleString('tr-TR', { maximumFractionDigits: 0 });
            }

            const bicycleQuantityEl = document.getElementById('bicycleQuantity');
            if (bicycleQuantityEl && typeof currentData.bicycleQuantity === 'number') {
                bicycleQuantityEl.textContent = currentData.bicycleQuantity.toLocaleString('tr-TR') + ' adet';
            }

            const accessoryQuantityEl = document.getElementById('accessoryQuantity');
            if (accessoryQuantityEl && typeof currentData.accessoryQuantity === 'number') {
                accessoryQuantityEl.textContent = currentData.accessoryQuantity.toLocaleString('tr-TR') + ' adet';
            }

            const storeCountEl = document.getElementById('storeCount');
            if (storeCountEl && currentData.stores && currentData.dealers) {
                storeCountEl.textContent = (Object.keys(currentData.stores).length + Object.keys(currentData.dealers).length).toLocaleString('tr-TR');
            }

            const customerCountEl = document.getElementById('customerCount');
            if (customerCountEl && typeof currentData.customerCount === 'number') {
                customerCountEl.textContent = currentData.customerCount.toLocaleString('tr-TR');
            }

            // Update stores list
            updateStoresList();
            
            // Update dealers list
            updateDealersList();
            
            // Update chart
            updateChart();
        }

        function updateStoresList() {
            if (!currentData) return;
            
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? '₺' : currentCurrency === 'USD' ? '$' : '€';
            
            const storesList = document.getElementById('storesList');
            storesList.innerHTML = '';

            // Sort stores by sales amount
            const sortedStores = Object.values(currentData.stores)
                .sort((a, b) => b.totalTL - a.totalTL);

            sortedStores.forEach(store => {
                const storeDiv = document.createElement('div');
                storeDiv.className = 'store-item';
                
                const amount = store.totalTL / rate;
                
                storeDiv.innerHTML = `
                    <div class="store-name">${store.name}</div>
                    <div class="store-stats">
                        <div class="store-amount">${symbol}${amount.toLocaleString('tr-TR', { maximumFractionDigits: 0 })}</div>
                        <div class="store-count">${store.orderCount} sipariş</div>
                        <div class="store-count">${store.customers.size} müşteri</div>
                    </div>
                `;
                
                storesList.appendChild(storeDiv);
            });
        }

        function updateDealersList() {
            if (!currentData) return;
            
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? '₺' : currentCurrency === 'USD' ? '$' : '€';
            
            const dealersList = document.getElementById('dealersList');
            dealersList.innerHTML = '';

            // Sort dealers by sales amount
            const sortedDealers = Object.values(currentData.dealers)
                .sort((a, b) => b.totalTL - a.totalTL);

            sortedDealers.forEach(dealer => {
                const dealerDiv = document.createElement('div');
                dealerDiv.className = 'dealer-item';
                
                const amount = dealer.totalTL / rate;
                
                dealerDiv.innerHTML = `
                    <div>
                        <span class="dealer-name">${dealer.name}</span>
                        <span class="dealer-type">${dealer.type}</span>
                    </div>
                    <div class="store-stats">
                        <div class="store-amount">${symbol}${amount.toLocaleString('tr-TR', { maximumFractionDigits: 0 })}</div>
                        <div class="store-count">${dealer.orderCount} sipariş</div>
                        <div class="store-count">${dealer.customers.size} müşteri</div>
                    </div>
                `;
                
                dealersList.appendChild(dealerDiv);
            });
        }

        function updateChart() {
            updateStoresChart();
            updateCategoryChart();
            updatePerformanceChart();
            updateMonthlyTrendChart();
        }

        function updateStoresChart() {
            if (!currentData) return;
            
            const ctx = document.getElementById('salesChart').getContext('2d');
            
            // Prepare data for chart
            const storeNames = Object.values(currentData.stores).map(store => store.name);
            const storeAmounts = Object.values(currentData.stores).map(store => store.totalTL);
            
            const dealerNames = Object.values(currentData.dealers).map(dealer => `${dealer.name} (${dealer.type})`);
            const dealerAmounts = Object.values(currentData.dealers).map(dealer => dealer.totalTL);
            
            // Destroy existing chart if it exists
            if (salesChartInstance) {
                salesChartInstance.destroy();
            }
            
            // Create new chart
            salesChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [...storeNames, ...dealerNames],
                    datasets: [{
                        label: 'Satış Tutarı (TL)',
                        data: [...storeAmounts, ...dealerAmounts],
                        backgroundColor: [
                            ...storeNames.map(() => '#3498db'),
                            ...dealerNames.map(() => '#27ae60')
                        ],
                        borderColor: [
                            ...storeNames.map(() => '#2980b9'),
                            ...dealerNames.map(() => '#229954')
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '₺' + value.toLocaleString('tr-TR');
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        function updateCategoryChart() {
            if (!currentData || !currentData.categories) return;
            
            const ctx = document.getElementById('categoryChart').getContext('2d');
            
            // Sort categories by sales amount
            const sortedCategories = Object.values(currentData.categories)
                .sort((a, b) => b.totalTL - a.totalTL)
                .slice(0, 10); // Top 10 categories
            
            const categoryNames = sortedCategories.map(cat => cat.name);
            const categoryAmounts = sortedCategories.map(cat => cat.totalTL);
            const categoryColors = sortedCategories.map(cat => 
                cat.type === 'bicycle' ? '#e74c3c' : '#3498db'
            );
            
            // Destroy existing chart if it exists
            if (categoryChartInstance) {
                categoryChartInstance.destroy();
            }
            
            // Create new chart
            categoryChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: categoryNames,
                    datasets: [{
                        data: categoryAmounts,
                        backgroundColor: categoryColors,
                        borderColor: categoryColors,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'right'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${context.label}: ₺${value.toLocaleString('tr-TR')} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updatePerformanceChart() {
            if (!currentData || !currentData.categories) return;
            
            const ctx = document.getElementById('performanceChartCanvas').getContext('2d');
            const analysisDiv = document.getElementById('performanceAnalysis');
            
            // Sort categories by performance (sales amount)
            const sortedCategories = Object.values(currentData.categories)
                .sort((a, b) => b.totalTL - a.totalTL)
                .slice(0, 5); // Top 5 categories
            
            // Update performance analysis cards
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? '₺' : currentCurrency === 'USD' ? '$' : '€';
            
            analysisDiv.innerHTML = sortedCategories.map((category, index) => `
                <div class="performance-card" onclick="showCategoryDetail('${category.name}')" style="cursor: pointer;">
                    <div class="performance-category">
                        ${index + 1}. ${category.name} 
                        <span style="color: ${category.type === 'bicycle' ? '#e74c3c' : '#3498db'}; font-size: 12px;">
                            (${category.type === 'bicycle' ? '🚲 Bisiklet' : '🔧 Aksesuar'})
                        </span>
                        ${category.subcategories && category.subcategories.length > 0 ? 
                            `<div style="font-size: 11px; color: #666; margin-top: 4px;">Alt: ${category.subcategories.join(', ')}</div>` : ''}
                    </div>
                    <div class="performance-stats">
                        <div class="performance-amount">${symbol}${(category.totalTL / rate).toLocaleString('tr-TR', { maximumFractionDigits: 0 })}</div>
                        <div class="performance-count">${category.quantity} adet</div>
                        <div class="performance-count">${category.products.length} çeşit ürün</div>
                    </div>
                </div>
            `).join('');
            
            // Create bar chart
            const categoryNames = sortedCategories.map(cat => cat.name);
            const categoryAmounts = sortedCategories.map(cat => cat.totalTL);
            
            // Destroy existing chart if it exists
            if (performanceChartInstance) {
                performanceChartInstance.destroy();
            }
            
            // Create new chart
            performanceChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: categoryNames,
                    datasets: [{
                        label: 'Satış Tutarı (TL)',
                        data: categoryAmounts,
                        backgroundColor: '#27ae60',
                        borderColor: '#229954',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '₺' + value.toLocaleString('tr-TR');
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        function updateMonthlySalesChart() {
            // Get all files from memory to create monthly trend
            const allData = excelMemory.getAllData();
            const monthlyBreakdown = allData.monthlyBreakdown;
            
            if (Object.keys(monthlyBreakdown).length < 1) {
                // Show message if no data
                const statsDiv = document.getElementById('monthlyStatsContent');
                if (statsDiv) {
                    statsDiv.innerHTML = '<div style="color: #666; font-style: italic;">Aylık trend için en az 1 aylık veri gerekli.</div>';
                }
                return;
            }
            
            const canvas = document.getElementById('monthlySalesCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Sort months chronologically
            const sortedMonths = Object.entries(monthlyBreakdown)
                .sort((a, b) => a[0].localeCompare(b[0]));
            
            const monthNames = {
                '01': 'Ocak', '02': 'Şubat', '03': 'Mart', '04': 'Nisan',
                '05': 'Mayıs', '06': 'Haziran', '07': 'Temmuz', '08': 'Ağustos',
                '09': 'Eylül', '10': 'Ekim', '11': 'Kasım', '12': 'Aralık'
            };
            
            // Convert TL amounts to USD
            const labels = [];
            const dataUSD = [];
            const dataTL = [];
            
            for (const [monthKey, tlAmount] of sortedMonths) {
                const [year, month] = monthKey.split('-');
                const monthName = monthNames[month] || month;
                labels.push(`${monthName} ${year}`);
                
                // Convert to USD using currency converter
                const usdAmount = currencyConverter.convert(tlAmount, 'TL', 'USD');
                dataUSD.push(usdAmount);
                dataTL.push(tlAmount);
            }
            
            // Calculate statistics
            const totalUSD = dataUSD.reduce((sum, val) => sum + val, 0);
            const avgUSD = totalUSD / dataUSD.length;
            const maxUSD = Math.max(...dataUSD);
            const minUSD = Math.min(...dataUSD);
            const maxMonth = labels[dataUSD.indexOf(maxUSD)];
            const minMonth = labels[dataUSD.indexOf(minUSD)];
            
            // Growth calculation
            let growthText = '';
            if (dataUSD.length > 1) {
                const lastMonth = dataUSD[dataUSD.length - 1];
                const prevMonth = dataUSD[dataUSD.length - 2];
                const growth = ((lastMonth - prevMonth) / prevMonth * 100).toFixed(1);
                const growthColor = growth >= 0 ? '#27ae60' : '#e74c3c';
                const growthIcon = growth >= 0 ? '📈' : '📉';
                growthText = `<div style="color: ${growthColor};">${growthIcon} Son aya göre: %${growth}</div>`;
            }
            
            // Update statistics
            const statsDiv = document.getElementById('monthlyStatsContent');
            if (statsDiv) {
                statsDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <div><strong>💰 Toplam:</strong> ${currencyConverter.format(totalUSD, 'USD')}</div>
                            <div><strong>📊 Ortalama:</strong> ${currencyConverter.format(avgUSD, 'USD')}</div>
                            <div><strong>📈 En Yüksek:</strong> ${currencyConverter.format(maxUSD, 'USD')} <span style="color: #666;">(${maxMonth})</span></div>
                        </div>
                        <div>
                            <div><strong>📉 En Düşük:</strong> ${currencyConverter.format(minUSD, 'USD')} <span style="color: #666;">(${minMonth})</span></div>
                            <div><strong>📅 Dönem:</strong> ${labels.length} ay</div>
                            ${growthText}
                        </div>
                    </div>
                `;
            }
            
            // Destroy existing chart
            if (monthlySalesChartInstance) {
                monthlySalesChartInstance.destroy();
            }
            
            // Create gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 400);
            gradient.addColorStop(0, 'rgba(52, 152, 219, 0.8)');
            gradient.addColorStop(1, 'rgba(52, 152, 219, 0.1)');
            
            // Create new chart
            monthlySalesChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Aylık Satış (USD)',
                        data: dataUSD,
                        borderColor: '#3498db',
                        backgroundColor: gradient,
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: '#3498db',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const usdVal = currencyConverter.format(context.raw, 'USD');
                                    const tlVal = currencyConverter.format(dataTL[index], 'TL');
                                    return [
                                        `USD: ${usdVal}`,
                                        `TL: ${tlVal}`
                                    ];
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Aylar'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Satış Tutarı (USD)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateMonthlyTrendChart() {
            if (monthlyDataHistory.length < 2) {
                // Not enough data for trend analysis
                return;
            }
            
            const ctx = document.getElementById('monthlyTrendChart').getContext('2d');
            
            // Get all unique categories from all months
            const allCategories = new Set();
            monthlyDataHistory.forEach(monthData => {
                Object.keys(monthData.categories || {}).forEach(cat => allCategories.add(cat));
            });
            
            // Prepare trend data for top categories
            const topCategories = Array.from(allCategories).slice(0, 5);
            const datasets = [];
            const colors = ['#3498db', '#e74c3c', '#27ae60', '#f39c12', '#9b59b6'];
            
            topCategories.forEach((category, index) => {
                const data = monthlyDataHistory.map(monthData => {
                    return monthData.categories[category]?.totalTL || 0;
                });
                
                datasets.push({
                    label: category,
                    data: data,
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '20',
                    fill: false,
                    tension: 0.1
                });
            });
            
            // Destroy existing chart if it exists
            if (monthlyTrendChartInstance) {
                monthlyTrendChartInstance.destroy();
            }
            
            // Create new chart
            monthlyTrendChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: monthlyDataHistory.map(data => data.reportPeriod || 'Bilinmeyen'),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return '₺' + value.toLocaleString('tr-TR');
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        function showChart(chartType) {
            // Update button states
            document.querySelectorAll('.chart-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Show/hide chart containers
            document.getElementById('storesChart').style.display = chartType === 'stores' ? 'block' : 'none';
            document.getElementById('categoriesChart').style.display = chartType === 'categories' ? 'block' : 'none';
            document.getElementById('performanceChart').style.display = chartType === 'performance' ? 'block' : 'none';
            document.getElementById('monthlyChart').style.display = chartType === 'monthly' ? 'block' : 'none';
            document.getElementById('monthlySalesChart').style.display = chartType === 'monthlySales' ? 'block' : 'none';
            
            // Update monthly sales chart if selected
            if (chartType === 'monthlySales') {
                updateMonthlySalesChart();
            }
        }

        function showCategoryDetail(categoryName) {
            if (!currentData || !currentData.categories || !currentData.categories[categoryName]) {
                alert('Kategori detayları bulunamadı');
                return;
            }
            
            const category = currentData.categories[categoryName];
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? '₺' : currentCurrency === 'USD' ? '$' : '€';
            
            // Filter sales for this category
            const categorySales = currentData.sales.filter(sale => {
                // Check if this sale belongs to the category
                const productKod = sale.kod || '';
                const categoryInfo = categorizeProduct(productKod, sale.urun);
                const mainCategoryName = categoryInfo.mainCategory || categoryInfo.category || 'UNCATEGORIZED';
                return mainCategoryName === categoryName;
            });
            
            // Group by store/dealer
            const salesByLocation = {};
            categorySales.forEach(sale => {
                const location = sale.depo || 'Bilinmeyen';
                if (!salesByLocation[location]) {
                    salesByLocation[location] = { sales: 0, quantity: 0, orders: 0 };
                }
                salesByLocation[location].sales += sale.amountInTL || 0;
                salesByLocation[location].quantity += sale.miktar || 0;
                salesByLocation[location].orders += 1;
            });
            
            // Create detail popup
            let detailHTML = `
                <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                           background: white; padding: 30px; border-radius: 15px; 
                           box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 1000; max-width: 600px; max-height: 70vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 20px;">
                        <h2>📊 ${categoryName} Detayları</h2>
                        <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                                style="background: #e74c3c; color: white; border: none; border-radius: 50%; 
                                       width: 30px; height: 30px; cursor: pointer; margin-left: auto;">×</button>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <strong>Toplam:</strong> ${symbol}${(category.totalTL / rate).toLocaleString('tr-TR')} | 
                        <strong>Adet:</strong> ${category.quantity} | 
                        <strong>Çeşit:</strong> ${category.products.length}
                        ${category.subcategories.length > 0 ? `<br><strong>Alt Kategoriler:</strong> ${category.subcategories.join(', ')}` : ''}
                    </div>
                    
                    <h3>📍 Lokasyon Bazında Satışlar:</h3>
                    <div style="max-height: 300px; overflow-y: auto;">
            `;
            
            Object.entries(salesByLocation)
                .sort(([,a], [,b]) => b.sales - a.sales)
                .forEach(([location, data]) => {
                    detailHTML += `
                        <div style="display: flex; justify-content: space-between; padding: 10px; border-bottom: 1px solid #eee;">
                            <strong>${location}</strong>
                            <div>
                                ${symbol}${(data.sales / rate).toLocaleString('tr-TR')} | 
                                ${data.quantity} adet | 
                                ${data.orders} sipariş
                            </div>
                        </div>
                    `;
                });
            
            detailHTML += `</div></div>`;
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;';
            overlay.onclick = () => overlay.remove();
            
            overlay.innerHTML = detailHTML;
            document.body.appendChild(overlay);
        }

        function toggleCurrency(currency) {
            currentCurrency = currency;
            
            // Update button states
            document.querySelectorAll('.currency-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update display
            updateCurrencyDisplay();
        }

        function showSection(section) {
            // Update button states
            document.querySelectorAll('.section-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Show/hide tabs
            document.getElementById('storesTab').style.display = section === 'stores' ? 'block' : 'none';
            document.getElementById('dealersTab').style.display = section === 'dealers' ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.upload-section').appendChild(errorDiv);
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.querySelector('.upload-section').appendChild(successDiv);
            
            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }
    </script>
</body>
</html>