<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AylÄ±k SatÄ±ÅŸ Analiz Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.8em;
            margin-bottom: 10px;
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        .upload-area {
            border: 2px dashed #3498db;
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            background: #f8f9fa;
            transition: all 0.3s;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #2980b9;
            background: #e8f4f8;
        }

        .upload-area.dragover {
            border-color: #27ae60;
            background: #e8f8f0;
        }

        #fileInput {
            display: none;
        }

        .upload-text {
            font-size: 18px;
            color: #666;
            margin-bottom: 15px;
        }

        .upload-btn {
            background: #3498db;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .upload-btn:hover {
            background: #2980b9;
        }

        .analysis-section {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #3498db;
        }

        .stat-card h3 {
            color: #2c3e50;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #3498db;
        }
        .stat-detail {
            font-size: 10px;
            color: #7f8c8d;
            margin-top: 5px;
            text-align: center;
        }

        .stores-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .store-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
            transition: background 0.3s;
        }

        .store-item:hover {
            background: #f8f9fa;
        }

        .store-name {
            font-weight: 600;
            color: #2c3e50;
            font-size: 16px;
        }

        .store-stats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .store-amount {
            font-size: 18px;
            font-weight: bold;
            color: #27ae60;
        }

        .store-count {
            font-size: 14px;
            color: #666;
            background: #ecf0f1;
            padding: 4px 8px;
            border-radius: 12px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .success {
            background: #27ae60;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .currency-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .currency-btn {
            padding: 8px 16px;
            border: 2px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .currency-btn.active {
            background: #3498db;
            color: white;
        }

        .file-info {
            margin-top: 15px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 6px;
            font-size: 14px;
            color: #2c3e50;
        }

        .section-btn {
            padding: 10px 20px;
            border: 2px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .section-btn.active {
            background: #3498db;
            color: white;
        }

        .section-btn:hover:not(.active) {
            background: #e8f4f8;
        }

        .chart-btn {
            padding: 10px 20px;
            border: 2px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 14px;
        }

        .chart-btn.active {
            background: #3498db;
            color: white;
        }

        .chart-btn:hover:not(.active) {
            background: #e8f4f8;
        }

        .chart-container {
            animation: fadeIn 0.3s ease-in;
        }

        .performance-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .performance-category {
            font-weight: 600;
            color: #2c3e50;
        }

        .performance-stats {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .performance-amount {
            font-size: 18px;
            font-weight: bold;
            color: #27ae60;
        }

        .performance-count {
            font-size: 14px;
            color: #666;
            background: #ecf0f1;
            padding: 4px 8px;
            border-radius: 12px;
        }

        .tab-content {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Memory Management Styles */
        #memoryStatus {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }

        .memory-file {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }

        .file-name {
            font-weight: 600;
            color: #2c3e50;
        }

        .file-info {
            font-size: 12px;
            color: #6c757d;
        }

        .remove-btn {
            background: #dc3545;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .remove-btn:hover {
            background: #c82333;
        }

        .dealer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
            transition: background 0.3s;
            background: linear-gradient(90deg, #fff 0%, #f8f9fa 100%);
        }

        .dealer-item:hover {
            background: linear-gradient(90deg, #e8f4f8 0%, #f0f8ff 100%);
        }

        .dealer-name {
            font-weight: 600;
            color: #2c3e50;
            font-size: 16px;
        }

        .dealer-type {
            font-size: 12px;
            color: #666;
            background: #3498db;
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            margin-left: 8px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2.2em;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .store-stats {
                flex-direction: column;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“Š AylÄ±k SatÄ±ÅŸ Analiz Dashboard</h1>
            <p>Excel satÄ±ÅŸ raporu yÃ¼kleyerek aylÄ±k satÄ±ÅŸ analizlerini gÃ¶rÃ¼ntÃ¼leyin</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" onclick="document.getElementById('fileInput').click()">
                <div class="upload-text">ğŸ“ Excel dosyasÄ±nÄ± buraya sÃ¼rÃ¼kleyin veya tÄ±klayarak seÃ§in</div>
                <button class="upload-btn">Dosya SeÃ§</button>
                <input type="file" id="fileInput" accept=".xlsx,.xls" />
            </div>
            <div class="file-info" id="fileInfo" style="display: none;"></div>
            
            <!-- Quick Actions -->
            <div id="quickActions" style="margin-top: 15px; display: none;">
                <button onclick="showYearlyAnalysis()" class="section-btn" style="margin-right: 10px;">ğŸ“… YÄ±llÄ±k Analiz</button>
                <button onclick="excelMemory.files.clear(); excelMemory.updateMemoryDisplay();" class="section-btn" style="background: #dc3545; border-color: #dc3545;">ğŸ—‘ï¸ TÃ¼mÃ¼nÃ¼ Temizle</button>
            </div>
            
            <!-- Exchange Rates Info -->
            <div id="exchangeRatesInfo" style="margin-top: 15px; padding: 12px; background: #f8f9fa; border-radius: 6px; font-size: 12px; color: #666; display: none;">
                <strong>ğŸ’± DÃ¶viz KurlarÄ± (2025 Ocak-Temmuz OrtalamasÄ±):</strong><br>
                1 USD = â‚º${exchangeRates.USD.toFixed(3)} | 1 EUR = â‚º${exchangeRates.EUR.toFixed(3)} | EUR/USD = ${(1.1096).toFixed(4)}
                <div style="margin-top: 5px; font-size: 11px;">
                    <em>Kaynak: Piyasa verisi analizi</em>
                </div>
            </div>

            <!-- Memory Status -->
            <div id="memoryStatus" style="margin-top: 20px; display: none;"></div>
        </div>

        <div class="loading" id="loading">
            <div>ğŸ“Š Excel dosyasÄ± analiz ediliyor...</div>
        </div>

        <div class="analysis-section" id="analysisSection">
            <div class="currency-toggle">
                <button class="currency-btn active" onclick="toggleCurrency('TL')">TL</button>
                <button class="currency-btn" onclick="toggleCurrency('USD')">USD</button>
                <button class="currency-btn" onclick="toggleCurrency('EUR')">EUR</button>
            </div>

            <div class="period-info" id="periodInfo" style="margin-bottom: 20px; text-align: center; font-size: 16px; color: #2c3e50; background: #ecf0f1; padding: 10px; border-radius: 8px;">
                ğŸ“… Rapor DÃ¶nemi: -
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <h3>ğŸ’° Toplam SatÄ±ÅŸ (TÃ¼m Para Birimleri)</h3>
                    <div class="stat-value" id="totalSales">-</div>
                    <div class="currency-breakdown" id="currencyBreakdown" style="font-size: 14px; margin-top: 10px; color: #666;">
                        <div>ğŸ‡ºğŸ‡¸ USD: <span id="totalUSD">-</span></div>
                        <div>ğŸ‡ªğŸ‡º EUR: <span id="totalEUR">-</span></div>  
                        <div>ğŸ‡¹ğŸ‡· TL: <span id="totalTL">-</span></div>
                    </div>
                </div>
                <div class="stat-card">
                    <h3>ğŸ“¦ Toplam Adet</h3>
                    <div class="stat-value" id="totalQuantity">-</div>
                </div>
                <div class="stat-card">
                    <h3>ğŸš² Bisiklet SatÄ±ÅŸÄ±</h3>
                    <div class="stat-value" id="bicycleSales">-</div>
                    <div class="stat-detail">BÄ°SÄ°KLETLER + E-BÄ°KELER</div>
                </div>
                <div class="stat-card">
                    <h3>ğŸ”§ DiÄŸer SatÄ±ÅŸlar</h3>
                    <div class="stat-value" id="accessorySales">-</div>
                    <div class="stat-detail">AKSESUAR + YEDEK PARÃ‡A + TEKSTÄ°L + BIKE FIT</div>
                </div>
                <div class="stat-card">
                    <h3>ğŸš² Bisiklet Adedi</h3>
                    <div class="stat-value" id="bicycleQuantity">-</div>
                    <div class="stat-detail">BÄ°SÄ°KLETLER + E-BÄ°KELER</div>
                </div>
                <div class="stat-card">
                    <h3>ğŸ”§ DiÄŸer Adetler</h3>
                    <div class="stat-value" id="accessoryQuantity">-</div>
                    <div class="stat-detail">AKSESUAR + YEDEK PARÃ‡A + TEKSTÄ°L + BIKE FIT</div>
                </div>
                <div class="stat-card">
                    <h3>ğŸª MaÄŸaza/Bayi</h3>
                    <div class="stat-value" id="storeCount">-</div>
                </div>
                <div class="stat-card">
                    <h3>ğŸ‘¥ Toplam MÃ¼ÅŸteri</h3>
                    <div class="stat-value" id="customerCount">-</div>
                </div>
            </div>

            <div class="stores-section">
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="section-btn active" onclick="showSection('stores')">ğŸª MaÄŸaza SatÄ±ÅŸlarÄ±</button>
                    <button class="section-btn" onclick="showSection('dealers')">ğŸ¤ Bayi SatÄ±ÅŸlarÄ±</button>
                </div>
                
                <div id="storesTab" class="tab-content">
                    <h3 style="margin-bottom: 20px;">ğŸª MaÄŸaza BazÄ±nda SatÄ±ÅŸlar</h3>
                    <div id="storesList"></div>
                </div>
                
                <div id="dealersTab" class="tab-content" style="display: none;">
                    <h3 style="margin-bottom: 20px;">ğŸ¤ Bayi BazÄ±nda SatÄ±ÅŸlar</h3>
                    <div id="dealersList"></div>
                </div>
            </div>
            
            <div class="chart-section" style="margin-top: 30px; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);">
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="chart-btn active" onclick="showChart('stores')">ğŸª MaÄŸaza/Bayi SatÄ±ÅŸlarÄ±</button>
                    <button class="chart-btn" onclick="showChart('categories')">ğŸ“Š Kategori Analizi</button>
                    <button class="chart-btn" onclick="showChart('performance')">ğŸ† En Ä°yi Performans</button>
                    <button class="chart-btn" onclick="showChart('monthly')">ğŸ“ˆ AylÄ±k Trend</button>
                    <button class="chart-btn" onclick="showChart('monthlySales')">ğŸ’° USD SatÄ±ÅŸ Trendi</button>
                </div>
                
                <div id="storesChart" class="chart-container">
                    <h3 style="margin-bottom: 15px;">ğŸª MaÄŸaza ve Bayi SatÄ±ÅŸ PerformansÄ±</h3>
                    <canvas id="salesChart" width="400" height="200"></canvas>
                </div>
                
                <div id="categoriesChart" class="chart-container" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="margin: 0;">ğŸ“Š Kategori BazlÄ± SatÄ±ÅŸ Analizi</h3>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <select id="categoryViewMode" style="padding: 5px 10px; border-radius: 5px; border: 1px solid #ddd;">
                                <option value="all">TÃ¼m Kategoriler</option>
                                <option value="bicycles">BÄ°SÄ°KLETLER</option>
                                <option value="ebikes">E-BÄ°KELER</option>
                                <option value="accessories">AKSESUAR</option>
                                <option value="spareparts">YEDEK PARÃ‡A</option>
                                <option value="textile">TEKSTÄ°L</option>
                                <option value="bikefit">BIKE FIT</option>
                            </select>
                            <button onclick="exportCategoryData()" style="padding: 5px 10px; background: #3498db; color: white; border: none; border-radius: 5px; cursor: pointer;">
                                ğŸ“Š Veriyi DÄ±ÅŸa Aktar
                            </button>
                        </div>
                    </div>
                    
                    <!-- Summary cards -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-bottom: 20px;">
                        <div style="background: linear-gradient(135deg, #FF6B6B, #FF8E8E); color: white; padding: 15px; border-radius: 10px; text-align: center;">
                            <div style="font-size: 12px; opacity: 0.9;">En Ã‡ok Satan</div>
                            <div id="topCategoryName" style="font-weight: bold; font-size: 14px;">-</div>
                            <div id="topCategoryAmount" style="font-size: 16px; font-weight: bold;">-</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #4ECDC4, #6FD8D2); color: white; padding: 15px; border-radius: 10px; text-align: center;">
                            <div style="font-size: 12px; opacity: 0.9;">Toplam Kategori</div>
                            <div id="totalCategoriesCount" style="font-weight: bold; font-size: 18px;">-</div>
                            <div style="font-size: 12px; opacity: 0.9;">kategoride satÄ±ÅŸ</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #45B7D1, #6CBDE0); color: white; padding: 15px; border-radius: 10px; text-align: center;">
                            <div style="font-size: 12px; opacity: 0.9;">Bisiklet/DiÄŸer</div>
                            <div id="bikeAccessoryRatio" style="font-weight: bold; font-size: 14px;">-</div>
                            <div style="font-size: 12px; opacity: 0.9;">oranÄ± (6 kategori)</div>
                        </div>
                    </div>
                    
                    <!-- Chart area -->
                    <div style="height: 450px; position: relative; background: linear-gradient(135deg, #f8f9fa, #e9ecef); border-radius: 15px; padding: 20px;">
                        <canvas id="categoryChart"></canvas>
                    </div>
                    
                    <!-- Category details table -->
                    <div id="categoryDetailsTable" style="margin-top: 20px; display: none;">
                        <h4 style="margin-bottom: 10px;">ğŸ“‹ DetaylÄ± Kategori Analizi</h4>
                        <div style="overflow-x: auto;">
                            <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                                <thead style="background: #34495e; color: white;">
                                    <tr>
                                        <th style="padding: 12px; text-align: left;">Kategori</th>
                                        <th style="padding: 12px; text-align: right;">SatÄ±ÅŸ MiktarÄ±</th>
                                        <th style="padding: 12px; text-align: right;">YÃ¼zde</th>
                                        <th style="padding: 12px; text-align: right;">ÃœrÃ¼n SayÄ±sÄ±</th>
                                    </tr>
                                </thead>
                                <tbody id="categoryTableBody">
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <div id="performanceChart" class="chart-container" style="display: none;">
                    <h3 style="margin-bottom: 15px;">ğŸ† En Ä°yi Performans GÃ¶steren Kategoriler</h3>
                    <div id="performanceAnalysis"></div>
                    <canvas id="performanceChartCanvas" width="400" height="200"></canvas>
                </div>
                
                <div id="monthlyChart" class="chart-container" style="display: none;">
                    <h3 style="margin-bottom: 15px;">ğŸ“ˆ AylÄ±k Kategori Trendi</h3>
                    <p style="color: #666; font-style: italic; margin-bottom: 15px;">
                        ğŸ’¡ Bu grafik birden fazla aylÄ±k veri yÃ¼klendiÄŸinde kategori trendlerini gÃ¶sterecektir
                    </p>
                    <canvas id="monthlyTrendChart" width="400" height="200"></canvas>
                </div>
                
                <div id="monthlySalesChart" class="chart-container" style="display: none;">
                    <h3 style="margin-bottom: 15px;">ğŸ’° AylÄ±k Toplam SatÄ±ÅŸ Trendi (USD)</h3>
                    <canvas id="monthlySalesCanvas" width="400" height="200"></canvas>
                    <div id="monthlySalesStats" style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; font-size: 14px;">
                        <div class="stats-row" style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span><strong>ğŸ“Š Ä°statistikler:</strong></span>
                        </div>
                        <div id="monthlyStatsContent"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        let currentData = null;
        let currentCurrency = 'TL';
        
        // Memory management for multiple Excel files
        const excelMemory = {
            files: new Map(), // fileName -> {data, uploadDate, fileSize}
            maxFiles: 12, // Keep max 12 months
            getCurrentFiles: function() {
                return Array.from(this.files.entries()).map(([name, info]) => ({
                    name,
                    uploadDate: info.uploadDate,
                    fileSize: info.fileSize,
                    dataSize: info.data ? info.data.sales?.length || 0 : 0
                }));
            },
            addFile: function(fileName, data, fileSize) {
                // Clean up old files if we exceed maxFiles
                if (this.files.size >= this.maxFiles) {
                    const oldestEntry = Array.from(this.files.entries())
                        .sort((a, b) => new Date(a[1].uploadDate) - new Date(b[1].uploadDate))[0];
                    this.files.delete(oldestEntry[0]);
                    console.log(`ğŸ—‘ï¸ Removed old file from memory: ${oldestEntry[0]}`);
                }
                
                this.files.set(fileName, {
                    data: data,
                    uploadDate: new Date().toISOString(),
                    fileSize: fileSize
                });
                
                console.log(`ğŸ’¾ Added to memory: ${fileName} (${this.files.size}/${this.maxFiles} files)`);
                this.updateMemoryDisplay();
            },
            removeFile: function(fileName) {
                this.files.delete(fileName);
                this.updateMemoryDisplay();
            },
            getAllData: function() {
                const allData = {
                    totalSales: 0,
                    totalQuantity: 0,
                    categories: {},
                    dealers: {},
                    stores: {},
                    monthlyBreakdown: {},
                    files: []
                };
                
                for (const [fileName, info] of this.files.entries()) {
                    if (info.data) {
                        allData.files.push(fileName);
                        allData.totalSales += info.data.totalSales || 0;
                        allData.totalQuantity += info.data.totalQuantity || 0;
                        
                        // Merge categories
                        for (const [cat, amount] of Object.entries(info.data.categorySales || {})) {
                            allData.categories[cat] = (allData.categories[cat] || 0) + amount;
                        }
                        
                        // Merge dealers
                        for (const [dealer, amount] of Object.entries(info.data.dealerSales || {})) {
                            allData.dealers[dealer] = (allData.dealers[dealer] || 0) + amount;
                        }
                        
                        // Merge stores
                        for (const [store, amount] of Object.entries(info.data.storeSales || {})) {
                            allData.stores[store] = (allData.stores[store] || 0) + amount;
                        }
                        
                        // Extract month from filename or date
                        const month = this.extractMonth(fileName);
                        if (month) {
                            allData.monthlyBreakdown[month] = (allData.monthlyBreakdown[month] || 0) + (info.data.totalSales || 0);
                        }
                    }
                }
                
                return allData;
            },
            extractMonth: function(fileName) {
                // Try to extract month from filename patterns like "SATIÅ RAPORU-10.xlsx" or "2025-07-sales.xlsx"
                const patterns = [
                    /(\d{4})-(\d{2})/,  // 2025-07
                    /(\d{2})\.xlsx?$/,   // -10.xlsx
                    /(ocak|ÅŸubat|mart|nisan|mayÄ±s|haziran|temmuz|aÄŸustos|eylÃ¼l|ekim|kasÄ±m|aralÄ±k)/i
                ];
                
                for (const pattern of patterns) {
                    const match = fileName.match(pattern);
                    if (match) {
                        if (pattern === patterns[1]) {
                            return `2025-${match[1].padStart(2, '0')}`;
                        } else if (pattern === patterns[2]) {
                            const monthNames = {
                                'ocak': '01', 'ÅŸubat': '02', 'mart': '03', 'nisan': '04',
                                'mayÄ±s': '05', 'haziran': '06', 'temmuz': '07', 'aÄŸustos': '08',
                                'eylÃ¼l': '09', 'ekim': '10', 'kasÄ±m': '11', 'aralÄ±k': '12'
                            };
                            return `2025-${monthNames[match[1].toLowerCase()]}`;
                        } else {
                            return `${match[1]}-${match[2]}`;
                        }
                    }
                }
                return null;
            },
            updateMemoryDisplay: function() {
                const files = this.getCurrentFiles();
                const memoryDiv = document.getElementById('memoryStatus');
                const actionsDiv = document.getElementById('quickActions');
                
                if (!memoryDiv) return;
                
                if (files.length > 0) {
                    actionsDiv.style.display = 'block';
                    
                    let html = `<h4>ğŸ“š HafÄ±zadaki Excel DosyalarÄ± (${files.length}/${this.maxFiles})</h4>`;
                    files.forEach(file => {
                        const date = new Date(file.uploadDate).toLocaleDateString('tr-TR');
                        const size = (file.fileSize / 1024).toFixed(1);
                        html += `
                            <div class="memory-file">
                                <span class="file-name">${file.name}</span>
                                <span class="file-info">${date} | ${size}KB | ${file.dataSize} satÄ±r</span>
                                <button onclick="excelMemory.removeFile('${file.name}')" class="remove-btn">ğŸ—‘ï¸</button>
                            </div>
                        `;
                    });
                    memoryDiv.innerHTML = html;
                } else {
                    actionsDiv.style.display = 'none';
                    memoryDiv.innerHTML = '';
                }
            }
        };
        let monthlyDataHistory = []; // Store multiple months data for trend analysis
        
        // BizimHesap products data cache
        let bizimhesapProducts = null;
        
        // Chart instances
        let salesChartInstance = null;
        let categoryChartInstance = null;
        let performanceChartInstance = null;
        let monthlyTrendChartInstance = null;
        let monthlySalesChartInstance = null;
        
        // Load BizimHesap product data for category analysis
        // Enhanced SKU-based product database for Trek products
        const trekProductDatabase = {
            // E-Bikes (High-end)
            '5325334': { category: 'E-BÄ°KE', subCategory: 'Rail 9.8', type: 'bicycle', mainCategory: 'E-BÄ°KELER' },
            '5322911': { category: 'E-BÄ°KE', subCategory: 'Powerfly FS+ 6', type: 'bicycle', mainCategory: 'E-BÄ°KELER' },
            '5272065': { category: 'E-BÄ°KE', subCategory: 'Fuel EXe 9.9', type: 'bicycle', mainCategory: 'E-BÄ°KELER' },
            '5315136': { category: 'E-BÄ°KE', subCategory: 'Rail+ 5', type: 'bicycle', mainCategory: 'E-BÄ°KELER' },
            '5324290': { category: 'E-BÄ°KE', subCategory: 'Powerfly 4', type: 'bicycle', mainCategory: 'E-BÄ°KELER' },
            '5324291': { category: 'E-BÄ°KE', subCategory: 'Rail 5', type: 'bicycle', mainCategory: 'E-BÄ°KELER' },
            
            // Road Bikes
            '582181': { category: 'Road Bike', subCategory: 'Ã‰monda SL 6', type: 'bicycle', mainCategory: 'BÄ°SÄ°KLETLER' },
            '555607': { category: 'Road Bike', subCategory: 'Domane AL 2', type: 'bicycle', mainCategory: 'BÄ°SÄ°KLETLER' },
            
            // Mountain Bikes
            '593775': { category: 'Mountain Bike', subCategory: 'X-Caliber 8', type: 'bicycle', mainCategory: 'BÄ°SÄ°KLETLER' },
            '562401': { category: 'Mountain Bike', subCategory: 'Marlin 7', type: 'bicycle', mainCategory: 'BÄ°SÄ°KLETLER' },
            
            // Helmets
            '460497': { category: 'KASK', subCategory: 'Solstice MIPS', type: 'accessory', mainCategory: 'KASKLAR' },
            '578853': { category: 'KASK', subCategory: 'Circuit MIPS', type: 'accessory', mainCategory: 'KASKLAR' },
            '13458024': { category: 'KASK', subCategory: 'Velocis MIPS', type: 'accessory', mainCategory: 'KASKLAR' },
            
            // Clothing & Accessories
            '13407158': { category: 'GÄ°YÄ°M', subCategory: 'Bontrager Jersey', type: 'accessory', mainCategory: 'GÄ°YÄ°M' },
            '13428290': { category: 'GÄ°YÄ°M', subCategory: 'Trek Short', type: 'accessory', mainCategory: 'GÄ°YÄ°M' },
            
            // Components & Parts
            '13540566': { category: 'PARÃ‡A', subCategory: 'Bontrager Component', type: 'accessory', mainCategory: 'PARÃ‡ALAR' },
            '13540567': { category: 'PARÃ‡A', subCategory: 'Trek Component', type: 'accessory', mainCategory: 'PARÃ‡ALAR' },
            
            // Eyewear
            '100': { category: 'GÃ–ZLÃœK', subCategory: '100% Speedcraft', type: 'accessory', mainCategory: 'GÃ–ZLÃœKLER' },
            '200': { category: 'GÃ–ZLÃœK', subCategory: '100% S2', type: 'accessory', mainCategory: 'GÃ–ZLÃœKLER' },
            
            // Pattern-based matching for bulk accessories
            // Any code starting with '1345' = Bontrager accessories
            // Any code starting with '1354' = Trek components
            // Any code starting with '578' = Helmets
        };

        async function loadBizimHesapProducts() {
            if (bizimhesapProducts) return bizimhesapProducts;
            
            try {
                console.log('ğŸ”„ Loading BizimHesap products...');
                
                // Try proxy server first
                const response = await fetch('http://localhost:3002/api/b2b/products', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('ğŸ” BizimHesap API response structure:', data);
                
                if (data.data && data.data.products) {
                    bizimhesapProducts = data.data.products;
                    console.log(`âœ… Loaded ${bizimhesapProducts.length} BizimHesap products from API`);
                    return bizimhesapProducts;
                } else if (data.products) {
                    bizimhesapProducts = data.products;
                    console.log(`âœ… Loaded ${bizimhesapProducts.length} BizimHesap products from API`);
                    return bizimhesapProducts;
                } else {
                    console.log('âš ï¸ Unexpected API response structure:', Object.keys(data));
                    throw new Error('Invalid API response structure');
                }
            } catch (error) {
                console.error('âŒ Failed to load BizimHesap products from API:', error);
                console.log('ğŸ”„ Using local Trek product database fallback');
                
                // Convert local database to API-like structure
                bizimhesapProducts = Object.entries(trekProductDatabase).map(([code, info]) => ({
                    code: code,
                    sku: code,
                    title: info.subCategory,
                    category: info.category,
                    sub_category: info.subCategory,
                    type: info.type,
                    main_category: info.mainCategory
                }));
                
                console.log(`âœ… Loaded ${bizimhesapProducts.length} products from local Trek database`);
                return bizimhesapProducts;
            }
        }

        // Main category mapping - 6 general categories
        function getMainCategory(category) {
            if (!category) return 'AKSESUAR';
            
            const cat = category.toUpperCase();
            
            // E-BIKE CATEGORIES (electric bikes â†’ E-BÄ°KELER)
            if (cat.includes('ELEKTRÄ°KLÄ°') || cat.includes('ELECTRIC') || cat.includes('ğŸ”‹') ||
                cat.includes('FUEL EXE') || cat.includes('RAIL') || cat.includes('POWERFLY') ||
                cat.includes('DS+') || cat.includes('DS +') || cat.includes('FX+') || cat.includes('FX +') ||
                cat.includes('VERVE+') || cat.includes('VERVE +') || cat.includes('TOWNIE GO') ||
                cat.includes('MARLIN+') || cat.includes('MARLIN +') || cat.includes('DOMANE+')) {
                console.log(`âš¡ E-BIKE DETECTED: "${category}" â†’ E-BÄ°KELER`);
                return 'E-BÄ°KELER';
            }
            
            // REGULAR BICYCLE CATEGORIES (non-electric bikes â†’ BÄ°SÄ°KLETLER)
            if (cat.includes('BÄ°SÄ°KLET') || cat.includes('BISIKLET') || cat.includes('BIKE') ||
                // Road bikes
                cat.includes('MADONE') || cat.includes('EMONDA') || cat.includes('DOMANE') ||
                cat.includes('SPEED CONCEPT') ||
                // Gravel bikes
                cat.includes('GRAVEL') || cat.includes('CHECKPOINT') || cat.includes('CHECKMATE') ||
                // Mountain bikes  
                cat.includes('MARLIN') || cat.includes('PROCALIBER') || cat.includes('SUPERCALIBER') ||
                cat.includes('TOP FUEL') || cat.includes('FUEL EX') ||
                // City bikes
                cat.includes('FX') || cat.includes('DS') || cat.includes('VERVE') || 
                cat.includes('ELECTRA') || cat.includes('TOWNIE') ||
                // Hybrid bikes
                cat.includes('DUAL SPORT') || cat.includes('HYBRID')) {
                return 'BÄ°SÄ°KLETLER';
            }
            
            // TEXTILE CATEGORIES (clothing and accessories â†’ TEKSTÄ°L)
            if (cat.includes('AYAKKABI') || cat.includes('KILIF') || cat.includes('Ã‡ORAP') ||
                cat.includes('ELDÄ°VEN') || cat.includes('GLOVE') || cat.includes('FORMA') || 
                cat.includes('JERSEY') || cat.includes('GOBÄ°K') || cat.includes('Ä°Ã‡LÄ°K') ||
                cat.includes('KASK') || cat.includes('HELMET') || cat.includes('RÃœZGARLIK') || 
                cat.includes('YAÄMURLUK') || cat.includes('TAYT') || cat.includes('ÅORT') ||
                cat.includes('GÃ–ZLÃœK') || cat.includes('GLASSES') || cat.includes('GÄ°YÄ°M')) {
                console.log(`ğŸ‘• TEXTILE DETECTED: "${category}" â†’ TEKSTÄ°L`);
                return 'TEKSTÄ°L';
            }
            
            // SPARE PARTS CATEGORIES (components and parts â†’ YEDEK PARÃ‡A)
            if (cat.includes('GÄ°DON') || cat.includes('HANDLEBAR') || cat.includes('AEROBAR') ||
                cat.includes('ANAHTAR') || cat.includes('BATARYA') || cat.includes('BATTERY') ||
                cat.includes('BLENDR') || cat.includes('Ä°Ã‡ LASTÄ°K') || cat.includes('INNER TUBE') ||
                cat.includes('JANT') || cat.includes('WHEEL') || cat.includes('LASTÄ°K') || 
                cat.includes('TIRE') || cat.includes('PEDAL') || cat.includes('SELE') || 
                cat.includes('SADDLE') || cat.includes('KADRO') || cat.includes('FRAME') ||
                cat.includes('PARÃ‡A') || cat.includes('COMPONENT')) {
                console.log(`ğŸ”§ SPARE PART DETECTED: "${category}" â†’ YEDEK PARÃ‡A`);
                return 'YEDEK PARÃ‡A';
            }
            
            // BIKE FIT & SERVICE CATEGORIES (services â†’ BIKE FIT)
            if (cat.includes('SERVÄ°S') || cat.includes('SERVICE') || cat.includes('BAKIM') || 
                cat.includes('TAMIR') || cat.includes('FIT') || cat.includes('HIZMET')) {
                console.log(`ğŸ”§ SERVICE DETECTED: "${category}" â†’ BIKE FIT`);
                return 'BIKE FIT';
            }
            
            // ACCESSORIES (everything else â†’ AKSESUAR)
            console.log(`ğŸ“¦ ACCESSORY DETECTED: "${category}" â†’ AKSESUAR`);
            return 'AKSESUAR';
        }
        
        // Determine if product is bicycle or accessory based on TriEye category schema
        function getBicycleOrAccessory(category) {
            if (!category) return 'accessory';
            
            const cat = category.toUpperCase();
            
            // BICYCLE CATEGORIES (from TriEye schema)
            const bicycleCategories = [
                // Main bicycle category
                'BÄ°SÄ°KLET', 'BISIKLET', 'BIKE', 'CYCLE',
                
                // Road bikes
                'YOL BÄ°SÄ°KLETÄ°', 'YOL BÄ°SÄ°KLET', 'MADONE', 'EMONDA', 'DOMANE', 'SPEED CONCEPT',
                
                // Gravel bikes  
                'GRAVEL', 'CHECKMATE', 'CHECKPOINT',
                
                // Electric bikes
                'ELEKTRÄ°KLÄ° BÄ°SÄ°KLET', 'ELEKTRÄ°KLÄ° BÄ°SÄ°KLETÄ°', 'ELECTRIC',
                'FUEL EXE', 'RAIL', 'POWERFLY FS', 'POWERFLY', 'DS +', 'DS+', 
                'FX+', 'VERVE +', 'VERVE+', 'TOWNIE GO', 'MARLIN +', 'MARLIN+',
                
                // Mountain bikes
                'MOUNTAIN', 'MARLIN', 'PROCALIBER', 'SUPERCALIBER', 'FUEL EX', 'TOP FUEL',
                
                // City bikes
                'ÅEHÄ°R BÄ°SÄ°KLETÄ°', 'ÅEHÄ°R BÄ°SÄ°KLET', 'CITY',
                'FX BÄ°SÄ°KLET', 'FX BÄ°SÄ°KLETÄ°', 'FX', 'DS BÄ°SÄ°KLET', 'DS BÄ°SÄ°KLETÄ°', 'DS',
                'VERVE', 'ELECTRA', 'TOWNIE', 'DUAL SPORT', 'HYBRID'
            ];
            
            // Check if category matches any bicycle category
            for (const bikeCategory of bicycleCategories) {
                if (cat.includes(bikeCategory)) {
                    console.log(`ğŸš² BICYCLE DETECTED: "${category}" â†’ bicycle (matched: ${bikeCategory})`);
                    return 'bicycle';
                }
            }
            
            // ACCESSORY CATEGORIES (everything else)
            console.log(`ğŸ”§ ACCESSORY DETECTED: "${category}" â†’ accessory`);
            return 'accessory';
        }

        // Enhanced product categorization using local database + API fallback
        function categorizeProduct(productCode, productName) {
            // Ensure parameters are defined
            productCode = productCode || '';
            productName = productName || '';
            
            console.log(`\nğŸ” === CATEGORIZING PRODUCT ===`);
            console.log(`ğŸ“‹ Name: "${productName}"`);
            console.log(`ğŸ·ï¸  Code: "${productCode}" (type: ${typeof productCode})`);
            console.log(`ğŸ“¦ BizimHesap products loaded: ${bizimhesapProducts ? bizimhesapProducts.length : 'NOT LOADED'}`);
            
            // First try local Trek database lookup by code matching (most accurate)
            if (productCode && trekProductDatabase[String(productCode)]) {
                const localProduct = trekProductDatabase[String(productCode)];
                console.log(`ğŸ¯ LOCAL DATABASE EXACT MATCH: Code "${productCode}" â†’ ${localProduct.subCategory} (${localProduct.category})`);
                
                return {
                    type: localProduct.type,
                    category: localProduct.subCategory,
                    mainCategory: localProduct.mainCategory,
                    source: 'LOCAL_DB_EXACT'
                };
            }
            
            // Pattern-based matching for common SKU patterns
            if (productCode) {
                const code = String(productCode);
                
                // Bontrager accessories (13458xxx series)
                if (code.startsWith('1345')) {
                    console.log(`ğŸ¯ PATTERN MATCH: Code "${productCode}" â†’ Accessory (Pattern: 1345xxxx)`);
                    return {
                        type: 'accessory',
                        category: 'Accessory',
                        mainCategory: 'YEDEK PARÃ‡A',
                        source: 'PATTERN_1345'
                    };
                }
                
                // Trek components (13540xxx series)
                if (code.startsWith('1354')) {
                    console.log(`ğŸ¯ PATTERN MATCH: Code "${productCode}" â†’ Component (Pattern: 1354xxxx)`);
                    return {
                        type: 'accessory',
                        category: 'Component',
                        mainCategory: 'AEROBAR - GÄ°DON',
                        source: 'PATTERN_1354'
                    };
                }
                
                // Helmets (578xxx series)
                if (code.startsWith('578')) {
                    console.log(`ğŸ¯ PATTERN MATCH: Code "${productCode}" â†’ Helmet (Pattern: 578xxx)`);
                    return {
                        type: 'accessory',
                        category: 'Helmet',
                        mainCategory: 'KASKLAR',
                        source: 'PATTERN_578'
                    };
                }
                
                // High-end bikes (5xxxxxx series) - check if E-bike first
                if (code.startsWith('5') && code.length >= 6) {
                    const name = (productName || '').toLowerCase();
                    
                    // Check if this is an E-bike based on product name
                    const ebikeKeywords = ['rail', 'powerfly', 'fuel exe', 'verve+', 'fx+', 'ds+', 'townie go', 'marlin+', 'domane+', 'elektrikli', 'electric', 'e-bike', '+'];
                    const isEbike = ebikeKeywords.some(keyword => name.includes(keyword));
                    
                    if (isEbike) {
                        console.log(`âš¡ PATTERN MATCH E-BIKE: Code "${productCode}" â†’ E-bike (Pattern: 5xxxxxx, Name: ${productName})`);
                        return {
                            type: 'bicycle',
                            category: 'E-BIKE',
                            mainCategory: 'E-BÄ°KELER',
                            source: 'PATTERN_5X_EBIKE'
                        };
                    } else {
                        console.log(`ğŸš² PATTERN MATCH: Code "${productCode}" â†’ High-end Bicycle (Pattern: 5xxxxxx)`);
                        return {
                            type: 'bicycle',
                            category: 'High-end Bicycle',
                            mainCategory: 'BÄ°SÄ°KLETLER',
                            source: 'PATTERN_5X'
                        };
                    }
                }
                
                // 100% Eyewear (100-999 range)
                if (code.length <= 3 && /^\d+$/.test(code)) {
                    const num = parseInt(code);
                    if (num >= 100 && num <= 999) {
                        console.log(`ğŸ¯ PATTERN MATCH: Code "${productCode}" â†’ 100% Eyewear (Pattern: 1xx-9xx)`);
                        return {
                            type: 'accessory',
                            category: '100% Eyewear',
                            mainCategory: 'GÃ–ZLÃœKLER',
                            source: 'PATTERN_100'
                        };
                    }
                }
            }
            
            // Second try API/loaded products lookup by code matching
            if (bizimhesapProducts && bizimhesapProducts.length > 0) {
                let apiProduct = null;
                
                // Priority 1: Exact code match with stock_code (most reliable)  
                if (productCode) {
                    // Convert both to string and clean whitespace for comparison
                    const excelCode = String(productCode).trim();
                    console.log(`ğŸ” Searching for Excel code: "${excelCode}"`);
                    
                    // Debug: show first few API products
                    if (bizimhesapProducts.length > 0) {
                        console.log(`ğŸ“Š Sample API products (first 3):`);
                        bizimhesapProducts.slice(0, 3).forEach((p, i) => {
                            console.log(`  ${i+1}. Code: "${p.code}", Barcode: "${p.barcode}", Title: "${p.title}", Category: "${p.category}"`);
                        });
                    }
                    
                    apiProduct = bizimhesapProducts.find(p => {
                        const apiCode = String(p.code || '').trim();
                        const apiBarcode = String(p.barcode || '').trim();
                        const apiSku = String(p.sku || '').trim();
                        
                        const matches = apiCode === excelCode || 
                                       apiBarcode === excelCode || 
                                       apiSku === excelCode;
                        
                        if (matches) {
                            console.log(`âœ… MATCH FOUND! Excel "${excelCode}" === API "${apiCode}" (${p.title})`);
                        }
                        
                        return matches;
                    });
                    
                    if (apiProduct) {
                        console.log(`ğŸ¯ API EXACT CODE MATCH: Excel code "${excelCode}" â†’ API product "${apiProduct.title}"`);
                        console.log(`ğŸ“‹ API Product Details:`, {
                            code: apiProduct.code,
                            barcode: apiProduct.barcode,
                            category: apiProduct.category,
                            brand: apiProduct.brand,
                            title: apiProduct.title
                        });
                        
                        const productCategory = apiProduct.category || 'UNCATEGORIZED';
                        let productType = getBicycleOrAccessory(productCategory);
                        let mainCat = getMainCategory(productCategory);
                        
                        // Override with E-bike detection if this is a bicycle
                        if (productType === 'bicycle') {
                            const productTitle = (apiProduct.title || '').toLowerCase();
                            const ebikeKeywords = ['rail', 'powerfly', 'fuel exe', 'verve+', 'fx+', 'ds+', 'townie go', 'marlin+', 'domane+', 'elektrikli', 'electric', 'e-bike', '+'];
                            const isEbike = ebikeKeywords.some(keyword => productTitle.includes(keyword));
                            
                            if (isEbike) {
                                mainCat = 'E-BÄ°KELER';
                                console.log(`âš¡ API E-BIKE DETECTED: "${apiProduct.title}" â†’ E-BÄ°KELER (matched: ${ebikeKeywords.find(k => productTitle.includes(k))})`);
                            }
                        }
                        
                        console.log(`ğŸ¯ CATEGORIZED: "${productCategory}" â†’ Main: "${mainCat}", Type: "${productType}"`);
                        
                        return {
                            type: productType,
                            category: productCategory,
                            mainCategory: mainCat,
                            source: 'API_EXACT'
                        };
                    } else {
                        console.log(`âŒ NO API MATCH found for Excel code: "${excelCode}"`);
                    }
                }
                
                // Priority 2: Partial code match
                if (!apiProduct && productCode) {
                    const codeStr = String(productCode);
                    apiProduct = bizimhesapProducts.find(p => 
                        (p.code && String(p.code).includes(codeStr)) ||
                        (p.sku && String(p.sku).includes(codeStr)) ||
                        (codeStr.includes(String(p.code)) && String(p.code).length > 3)
                    );
                    
                    if (apiProduct) {
                        console.log(`ğŸ” PARTIAL CODE MATCH: Excel code "${productCode}" ~ API code "${apiProduct.code}"`);
                    }
                }
                
                // Priority 3: Title matching (less reliable but still useful)
                if (!apiProduct && productName) {
                    // Try exact title match
                    apiProduct = bizimhesapProducts.find(p => 
                        p.title && p.title.toLowerCase() === productName.toLowerCase()
                    );
                    
                    // Try partial title match
                    if (!apiProduct) {
                        apiProduct = bizimhesapProducts.find(p => 
                            p.title && (
                                p.title.toLowerCase().includes(productName.toLowerCase()) ||
                                productName.toLowerCase().includes(p.title.toLowerCase())
                            )
                        );
                    }
                    
                    if (apiProduct) {
                        console.log(`ğŸ“ TITLE MATCH: Excel "${productName}" ~ API "${apiProduct.title}"`);
                    }
                }
                
                if (apiProduct && apiProduct.category) {
                    const category = apiProduct.category.toUpperCase();
                    console.log(`âœ… API match found: ${apiProduct.title} â†’ ${apiProduct.category}`);
                    
                    // Create main category mapping
                    const mainCategory = getMainCategory(apiProduct.category);
                    const productType = getBicycleOrAccessory(apiProduct.category);
                    
                    return { 
                        type: productType, 
                        category: apiProduct.category,
                        mainCategory: mainCategory,
                        source: 'api' 
                    };
                }
            }
            
            console.log(`âš ï¸ No API match, using name-based categorization`);
            // Fallback to name-based detection
            const result = categorizeByName(productName);
            result.source = 'name';
            result.mainCategory = getMainCategory(result.category);
            return result;
        }

        // Function to determine if product is bicycle or accessory by name
        function categorizeByName(productName) {
            if (!productName) return { type: 'accessory', category: 'UNCATEGORIZED' };
            
            const name = productName.toLowerCase();
            console.log(`ğŸ·ï¸ Name-based categorization for: "${name}"`);
            
            // E-bike indicators (check first for priority)
            const ebikeKeywords = [
                'rail', 'powerfly', 'fuel exe', 'verve+', 'fx+', 'ds+', 'townie go',
                'marlin+', 'domane+', 'allant', 'distrito', 'elektrikli', 'electric', 'e-bike',
                'ğŸ”‹', '+', 'plus', 'elektriklÄ±'
            ];
            
            // Check for e-bike first
            if (ebikeKeywords.some(keyword => name.includes(keyword))) {
                console.log(`âš¡ E-BIKE detected from name: "${productName}" (matched: ${ebikeKeywords.find(k => name.includes(k))})`);
                return { type: 'bicycle', category: 'E-BIKE', mainCategory: 'E-BÄ°KELER' };
            }
            
            // Regular bicycle indicators  
            const bicycleKeywords = [
                'bisiklet', 'bike', 'trek', 'fx', 'madone', 'domane', 'Ã©monda', 'checkpoint',
                'verve', 'dual sport', 'marlin', 'x-caliber', 'fuel ex', 'remedy', 'slash',
                'session', 'supercaliber', 'top fuel', 'procaliber', 'roscoe', 'townie'
            ];
            
            // Accessory/spare part indicators (expanded)
            const accessoryKeywords = [
                'aksesuar', 'parÃ§a', 'pompa', 'kask', 'eldiven', 'Ã§anta', 'Ä±ÅŸÄ±k', 'kilit',
                'matara', 'saddle', 'sele', 'gidon', 'fren', 'vites', 'zincir', 'lastik',
                'jant', 'pedal', 'bagaj', 'mudguard', 'Ã§amurluk', 'bontrager', 'servis',
                'helmet', 'glove', 'bottle', 'pump', 'tire', 'chain', 'brake', 'gear',
                'cable', 'grip', 'light', 'lock', 'bag', 'wheel', 'tube', 'pad',
                'hizmet', 'bakim', 'tamir', 'maintenance', 'service', 'repair'
            ];

            // Service/maintenance category
            const serviceKeywords = ['servis', 'hizmet', 'bakim', 'tamir', 'service', 'maintenance', 'repair', 'bike-fit'];
            
            // Check for service first
            if (serviceKeywords.some(keyword => name.includes(keyword))) {
                console.log(`âœ… Categorized as SERVICE: ${productName}`);
                return { type: 'accessory', category: 'SERVÄ°S' };
            }
            
            // Check for accessory (more specific)
            const foundAccessory = accessoryKeywords.find(keyword => name.includes(keyword));
            if (foundAccessory) {
                console.log(`âœ… Categorized as ACCESSORY (${foundAccessory}): ${productName}`);
                return { type: 'accessory', category: 'AKSESUAR' };
            }
            
            // Then check for bicycle
            const foundBicycle = bicycleKeywords.find(keyword => name.includes(keyword));
            if (foundBicycle) {
                console.log(`âœ… Categorized as BICYCLE (${foundBicycle}): ${productName}`);
                return { type: 'bicycle', category: 'BISIKLET' };
            }
            
            console.log(`âš ï¸ UNCATEGORIZED: "${productName}" (Code: ${typeof productCode !== 'undefined' ? productCode : 'undefined'}) - No matching keywords found`);
            console.log(`ğŸ” Checked sources: Local DB, Pattern matching, API matching, Name-based matching - ALL FAILED`);
            return { type: 'accessory', category: 'UNCATEGORIZED' };
        }
        
        // Exchange rates for currency conversion (2025 Jan-July averages from market data)
        const exchangeRates = {
            'TL': 1,
            'USD': 37.684, // 1 USD = 37.684 TL (2025 average)
            'EUR': 41.823  // 1 EUR = 41.823 TL (1.1096 EUR/USD * 37.684 USD/TL)
        };
        
        // Store distribution system for blank stores
        const storeDistributor = {
            targetStores: ['Alsancak', 'BahÃ§ekÃ¶y', 'OrtakÃ¶y', 'Caddebostan'],
            distributionIndex: 0,
            
            distributeBlankStore: function(amount, quantity = 1) {
                // Get target store for this blank entry (round-robin)
                const targetStore = this.targetStores[this.distributionIndex];
                this.distributionIndex = (this.distributionIndex + 1) % this.targetStores.length;
                
                console.log(`ğŸ“ Distributing blank store: ${amount} TL â†’ ${targetStore} (index: ${this.distributionIndex - 1})`);
                return targetStore;
            },
            
            resetDistribution: function() {
                this.distributionIndex = 0;
                console.log('ğŸ”„ Store distribution index reset');
            },
            
            getDistributionStats: function() {
                return {
                    stores: this.targetStores,
                    currentIndex: this.distributionIndex
                };
            }
        };

        // Currency conversion system
        const currencyConverter = {
            // Convert any amount to USD (base currency for totals)
            toUSD: function(amount, fromCurrency) {
                switch(fromCurrency.toUpperCase()) {
                    case 'USD': return amount;
                    case 'EUR': return amount * 1.1096; // EUR to USD average 2025
                    case 'TL': return amount / exchangeRates.USD; // TL to USD
                    default: return amount;
                }
            },
            
            // Convert any amount to any currency
            convert: function(amount, fromCurrency, toCurrency) {
                const usdAmount = this.toUSD(amount, fromCurrency);
                
                switch(toCurrency.toUpperCase()) {
                    case 'USD': return usdAmount;
                    case 'EUR': return usdAmount / 1.1096; // USD to EUR
                    case 'TL': return usdAmount * exchangeRates.USD; // USD to TL
                    default: return usdAmount;
                }
            },
            
            // Format currency with symbol
            format: function(amount, currency) {
                const symbols = { 'USD': '$', 'EUR': 'â‚¬', 'TL': 'â‚º' };
                const formatted = Math.abs(amount).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                return `${symbols[currency.toUpperCase()] || ''}${formatted}`;
            },
            
            // Get all currency totals for a given TL amount
            getAllTotals: function(tlAmount) {
                return {
                    TL: tlAmount,
                    USD: this.convert(tlAmount, 'TL', 'USD'),
                    EUR: this.convert(tlAmount, 'TL', 'EUR')
                };
            }
        };
        
        // Monthly exchange rate management
        const monthlyExchangeRates = {
            cache: new Map(), // Cache monthly average rates
            currentRates: {}, // Current active rates for this Excel file
            
            // Fetch monthly average USD/TRY rate for a specific month
            async fetchMonthlyUSDRate(year, month) {
                const monthKey = `${year}-${month.toString().padStart(2, '0')}`;
                
                if (this.cache.has(monthKey)) {
                    console.log(`ğŸ’¾ Using cached monthly USD rate for ${monthKey}: ${this.cache.get(monthKey)} TL`);
                    return this.cache.get(monthKey);
                }
                
                try {
                    // Fetch rates for first, mid, and last day of month to calculate average
                    const lastDay = new Date(year, month, 0).getDate();
                    const dates = [
                        `${year}-${month.toString().padStart(2, '0')}-01`,
                        `${year}-${month.toString().padStart(2, '0')}-15`,
                        `${year}-${month.toString().padStart(2, '0')}-${lastDay}`
                    ];
                    
                    const rates = [];
                    for (const date of dates) {
                        try {
                            const response = await fetch(`https://api.exchangerate-api.com/v4/historical/${date}/USD`);
                            if (response.ok) {
                                const data = await response.json();
                                if (data.rates?.TRY) {
                                    rates.push(data.rates.TRY);
                                }
                            }
                        } catch (e) {
                            console.warn(`âš ï¸ Could not fetch rate for ${date}:`, e.message);
                        }
                        
                        // Small delay to avoid rate limiting
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    if (rates.length > 0) {
                        const averageRate = rates.reduce((sum, rate) => sum + rate, 0) / rates.length;
                        this.cache.set(monthKey, averageRate);
                        console.log(`ğŸ’± Calculated monthly average USD rate for ${monthKey}: ${averageRate.toFixed(3)} TL (from ${rates.length} data points)`);
                        return averageRate;
                    }
                    
                } catch (error) {
                    console.error(`ğŸ’¥ Error fetching monthly rate for ${monthKey}:`, error);
                }
                
                // Fallback to default rates if API fails
                const fallbackRates = {
                    '2025-01': 37.2, '2025-02': 37.5, '2025-03': 37.8, '2025-04': 38.1,
                    '2025-05': 38.4, '2025-06': 38.7, '2025-07': 39.0, '2025-08': 39.3,
                    '2025-09': 39.6, '2025-10': 39.9, '2025-11': 40.2, '2025-12': 40.5
                };
                
                const fallbackRate = fallbackRates[monthKey] || 37.684;
                console.log(`ğŸ”„ Using fallback USD rate for ${monthKey}: ${fallbackRate} TL`);
                this.cache.set(monthKey, fallbackRate);
                return fallbackRate;
            },
            
            // Process sales data with month-specific rates
            async processWithMonthlyRates(salesData) {
                console.log('ğŸ”„ Processing sales with monthly exchange rates...');
                
                // Group sales by month
                const salesByMonth = {};
                for (const sale of salesData) {
                    const saleDate = this.parseDate(sale.tarih);
                    if (saleDate) {
                        const monthKey = `${saleDate.getFullYear()}-${(saleDate.getMonth() + 1).toString().padStart(2, '0')}`;
                        if (!salesByMonth[monthKey]) {
                            salesByMonth[monthKey] = [];
                        }
                        salesByMonth[monthKey].push(sale);
                    }
                }
                
                // Fetch rates for each month and recalculate
                for (const [monthKey, monthlySales] of Object.entries(salesByMonth)) {
                    const [year, month] = monthKey.split('-').map(Number);
                    const monthlyUSDRate = await this.fetchMonthlyUSDRate(year, month);
                    const monthlyEURRate = monthlyUSDRate / 1.1096; // EUR rate based on USD
                    
                    console.log(`ğŸ“Š Processing ${monthlySales.length} sales for ${monthKey} with USD rate: ${monthlyUSDRate.toFixed(3)} TL`);
                    
                    // Update each sale with correct monthly rate
                    for (const sale of monthlySales) {
                        const originalAmount = sale.toplam;
                        
                        // Recalculate amountInTL with correct monthly rate
                        if (sale.paraBirimi === 'EUR') {
                            sale.amountInTL = originalAmount * monthlyEURRate;
                        } else if (sale.paraBirimi === 'USD') {
                            sale.amountInTL = originalAmount * monthlyUSDRate;
                        }
                        // TL remains unchanged
                        
                        // Store the monthly rate used for this sale
                        sale.monthlyUSDRate = monthlyUSDRate;
                        sale.monthlyEURRate = monthlyEURRate;
                    }
                }
                
                return salesData;
            },
            
            parseDate(dateString) {
                if (!dateString) return null;
                
                const patterns = [
                    /(\d{2})\.(\d{2})\.(\d{4})/,  // 01.07.2025
                    /(\d{4})-(\d{2})-(\d{2})/,   // 2025-07-01
                    /(\d{2})\/(\d{2})\/(\d{4})/   // 01/07/2025
                ];
                
                for (const pattern of patterns) {
                    const match = dateString.match(pattern);
                    if (match) {
                        if (pattern === patterns[0] || pattern === patterns[2]) {
                            return new Date(parseInt(match[3]), parseInt(match[2]) - 1, parseInt(match[1]));
                        } else {
                            return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
                        }
                    }
                }
                
                return null;
            },
            
            // Update display with monthly rate information
            updateRateDisplay(salesData) {
                const exchangeRateInfo = document.getElementById('exchangeRatesInfo');
                if (!exchangeRateInfo) return;
                
                // Get unique months and their rates from sales data
                const monthlyRatesUsed = {};
                for (const sale of salesData) {
                    if (sale.monthlyUSDRate) {
                        const saleDate = this.parseDate(sale.tarih);
                        if (saleDate) {
                            const monthKey = `${saleDate.getFullYear()}-${(saleDate.getMonth() + 1).toString().padStart(2, '0')}`;
                            monthlyRatesUsed[monthKey] = sale.monthlyUSDRate;
                        }
                    }
                }
                
                const monthNames = {
                    '01': 'Ocak', '02': 'Åubat', '03': 'Mart', '04': 'Nisan',
                    '05': 'MayÄ±s', '06': 'Haziran', '07': 'Temmuz', '08': 'AÄŸustos',
                    '09': 'EylÃ¼l', '10': 'Ekim', '11': 'KasÄ±m', '12': 'AralÄ±k'
                };
                
                let rateInfo = '<strong>ğŸ’± AylÄ±k Ortalama DÃ¶viz KurlarÄ±:</strong><br>';
                const sortedMonths = Object.entries(monthlyRatesUsed).sort();
                
                if (sortedMonths.length > 0) {
                    sortedMonths.forEach(([monthKey, rate]) => {
                        const [year, month] = monthKey.split('-');
                        const monthName = monthNames[month] || month;
                        rateInfo += `${monthName} ${year}: 1 USD = â‚º${rate.toFixed(3)} | 1 EUR = â‚º${(rate / 1.1096).toFixed(3)}<br>`;
                    });
                    rateInfo += '<div style="margin-top: 5px; font-size: 11px;"><em>Kaynak: AylÄ±k ortalama API verisi (exchangerate-api.com)</em></div>';
                } else {
                    rateInfo += '2025 Genel OrtalamasÄ±: 1 USD = â‚º37.684 | 1 EUR = â‚º41.823<br>';
                    rateInfo += '<div style="margin-top: 5px; font-size: 11px;"><em>Kaynak: YÄ±llÄ±k ortalama verisi</em></div>';
                }
                
                exchangeRateInfo.innerHTML = rateInfo;
            }
        };

        // Dynamic exchange rate fetching (legacy - keeping for compatibility)
        const exchangeRateFetcher = {
            cache: new Map(), // Cache rates by date to avoid repeated API calls
            
            async fetchUSDRate(dateString) {
                try {
                    // Try to parse date from various formats
                    let targetDate = this.parseDate(dateString);
                    if (!targetDate) {
                        console.warn(`âš ï¸ Could not parse date: ${dateString}, using current rates`);
                        return null;
                    }
                    
                    const cacheKey = targetDate.toISOString().split('T')[0];
                    if (this.cache.has(cacheKey)) {
                        console.log(`ğŸ’¾ Using cached USD rate for ${cacheKey}`);
                        return this.cache.get(cacheKey);
                    }
                    
                    // Use exchangerate-api.com (free tier: 1500 requests/month)
                    const response = await fetch(`https://api.exchangerate-api.com/v4/latest/USD?date=${cacheKey}`);
                    
                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const usdToTry = data.rates?.TRY;
                    
                    if (usdToTry) {
                        this.cache.set(cacheKey, usdToTry);
                        console.log(`ğŸ’± Fetched USD rate for ${cacheKey}: 1 USD = ${usdToTry} TL`);
                        return usdToTry;
                    }
                    
                } catch (error) {
                    console.error('ğŸ’¥ Exchange rate fetch error:', error);
                }
                
                return null;
            },
            
            parseDate(dateString) {
                if (!dateString) return null;
                
                // Try various date formats
                const patterns = [
                    /(\d{2})\.(\d{2})\.(\d{4})/,  // 01.07.2025
                    /(\d{4})-(\d{2})-(\d{2})/,   // 2025-07-01
                    /(\d{2})\/(\d{2})\/(\d{4})/   // 01/07/2025
                ];
                
                for (const pattern of patterns) {
                    const match = dateString.match(pattern);
                    if (match) {
                        if (pattern === patterns[0] || pattern === patterns[2]) {
                            // DD.MM.YYYY or DD/MM/YYYY
                            return new Date(parseInt(match[3]), parseInt(match[2]) - 1, parseInt(match[1]));
                        } else {
                            // YYYY-MM-DD
                            return new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
                        }
                    }
                }
                
                return null;
            },
            
            async updateRatesForPeriod(reportPeriod) {
                if (!reportPeriod || typeof reportPeriod !== 'string') return;
                
                console.log(`ğŸ”„ Fetching exchange rates for period: ${reportPeriod}`);
                
                // Extract date from report period (e.g., "01.07.2025 - 31.07.2025")
                const dateMatch = reportPeriod.match(/(\d{2})\.(\d{2})\.(\d{4})/);
                if (dateMatch) {
                    const midPeriodDate = `${dateMatch[1]}.${dateMatch[2]}.${dateMatch[3]}`;
                    const usdRate = await this.fetchUSDRate(midPeriodDate);
                    
                    if (usdRate && usdRate !== exchangeRates.USD) {
                        // Update exchange rates for this session
                        exchangeRates.USD = usdRate;
                        exchangeRates.EUR = usdRate / 1.1096; // Adjust EUR rate proportionally
                        
                        // Update the display
                        const exchangeRateInfo = document.getElementById('exchangeRatesInfo');
                        if (exchangeRateInfo) {
                            exchangeRateInfo.innerHTML = `
                                <strong>ğŸ’± DÃ¶viz KurlarÄ± (${reportPeriod} DÃ¶nemi):</strong><br>
                                1 USD = â‚º${exchangeRates.USD.toFixed(3)} | 1 EUR = â‚º${exchangeRates.EUR.toFixed(3)} | EUR/USD = ${(1.1096).toFixed(4)}
                                <div style="margin-top: 5px; font-size: 11px;">
                                    <em>Kaynak: AnlÄ±k API verisi (exchangerate-api.com)</em>
                                </div>
                            `;
                        }
                        
                        console.log(`âœ… Updated USD rate: ${usdRate} TL (from API)`);
                        return usdRate;
                    }
                }
                
                return null;
            }
        };

        // File input handling
        console.log('ğŸ”§ Setting up event listeners...');
        const fileInput = document.getElementById('fileInput');
        if (fileInput) {
            fileInput.addEventListener('change', handleFileSelect);
            console.log('âœ… File input listener added');
        } else {
            console.error('âŒ File input element not found!');
        }
        
        // Drag and drop handling
        const uploadArea = document.querySelector('.upload-area');
        if (uploadArea) {
            console.log('âœ… Upload area found');
        } else {
            console.error('âŒ Upload area not found!');
        }
        
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, preventDefaults, false);
        });

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        ['dragenter', 'dragover'].forEach(eventName => {
            uploadArea.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, unhighlight, false);
        });

        function highlight(e) {
            uploadArea.classList.add('dragover');
        }

        function unhighlight(e) {
            uploadArea.classList.remove('dragover');
        }

        uploadArea.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            handleFiles(files);
        }

        function handleFiles(files) {
            console.log('ğŸ“‚ handleFiles called with:', files.length, 'files');
            
            if (files.length === 0) {
                console.log('âŒ No files provided');
                return;
            }
            
            const file = files[0];
            console.log('ğŸ“ Selected file:', file.name, file.size, 'bytes');
            
            // Validate file type
            if (!file.name.toLowerCase().match(/\.(xlsx|xls)$/)) {
                console.log('âŒ Invalid file type:', file.name);
                showError('LÃ¼tfen .xlsx veya .xls formatÄ±nda bir Excel dosyasÄ± seÃ§in.');
                return;
            }

            // Show file info
            document.getElementById('fileInfo').innerHTML = `
                ğŸ“ <strong>${file.name}</strong> (${formatFileSize(file.size)}) - ${new Date(file.lastModified).toLocaleString('tr-TR')}
            `;
            document.getElementById('fileInfo').style.display = 'block';

            console.log('âœ… Valid Excel file, starting processing...');
            
            // Process file
            processExcelFile(file);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        async function processExcelFile(file) {
            console.clear(); // Clear previous logs
            console.log('ğŸš€ STARTING EXCEL PROCESSING...');
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('analysisSection').style.display = 'none';

            // Load BizimHesap products first
            await loadBizimHesapProducts();

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const buffer = e.target.result;
                    const workbook = new ExcelJS.Workbook();
                    await workbook.xlsx.load(buffer);
                    
                    const worksheet = workbook.getWorksheet(1);
                    console.log('ğŸ“Š Worksheet dimensions:', worksheet.dimensions);
                    console.log('ğŸ”— Merged cells:', worksheet.model.merges);
                    
                    // Convert ExcelJS data to array format for compatibility (0-based indexing)
                    const jsonData = [];
                    const maxRow = worksheet.rowCount;
                    const maxCol = 12; // A-L columns
                    
                    for (let i = 1; i <= maxRow; i++) {
                        const row = worksheet.getRow(i);
                        const rowData = [];
                        
                        for (let j = 1; j <= maxCol; j++) {
                            const cell = row.getCell(j);
                            let value = cell.value;
                            
                            // Handle merged cells - get master value
                            if (cell.isMerged && cell.master) {
                                value = cell.master.value;
                            }
                            
                            // Convert value to string/number as needed
                            if (value !== null && value !== undefined) {
                                if (typeof value === 'object' && value.result) {
                                    value = value.result; // Handle formulas
                                } else if (typeof value === 'object' && value.text) {
                                    value = value.text; // Handle rich text
                                }
                            }
                            
                            // Convert to 0-based array index (j-1)
                            rowData[j-1] = value || '';
                        }
                        
                        // Convert to 0-based array index (i-1)
                        jsonData[i-1] = rowData;
                    }
                    
                    console.log('ğŸ“Š ExcelJS processed jsonData - First 10 rows:', jsonData.slice(0, 10));
                    
                    // Process data with initial exchange rates
                    currentData = processData(jsonData);
                    
                    // Apply monthly-specific exchange rates for precise calculations
                    if (currentData.sales && currentData.sales.length > 0) {
                        await monthlyExchangeRates.processWithMonthlyRates(currentData.sales);
                        
                        // Recalculate all totals with monthly rates
                        currentData = recalculateWithMonthlyRates(currentData);
                        
                        // Update rate display
                        monthlyExchangeRates.updateRateDisplay(currentData.sales);
                    }
                    
                    // Add to memory
                    excelMemory.addFile(file.name, currentData, file.size);
                    
                    // Show memory status
                    document.getElementById('memoryStatus').style.display = 'block';
                    
                    // Show exchange rates info
                    document.getElementById('exchangeRatesInfo').style.display = 'block';
                    
                    // Display results
                    displayAnalysis();
                    
                } catch (error) {
                    console.error('Excel processing error:', error);
                    showError('Excel dosyasÄ± iÅŸlenirken hata oluÅŸtu: ' + error.message);
                } finally {
                    document.getElementById('loading').style.display = 'none';
                }
            };
            
            reader.readAsArrayBuffer(file);
        }

        function processData(jsonData) {
            if (jsonData.length < 3) {
                throw new Error('Excel dosyasÄ±nda yeterli veri bulunamadÄ±');
            }

            // Find header row - Based on Excel analysis:
            // Row 0: "SATIÅ RAPORU"
            // Row 1: Date range "01.07.2025 - 31.07.2025"
            // Row 2: Headers "Belge No", "Tarih", "Depo", etc.
            // Row 3+: Data
            
            let headerRowIndex = 2; // Headers are in row 2 based on Excel analysis
            let dateRowIndex = 1;   // Row 1 contains the date range
            
            // Verify by checking if row 2 contains typical headers
            if (jsonData.length > 2) {
                const potentialHeaderRow = jsonData[2];
                if (potentialHeaderRow && potentialHeaderRow.length > 5) {
                    const headerText = potentialHeaderRow.join(' ').toLowerCase();
                    if (headerText.includes('belge') || headerText.includes('tarih') || 
                        headerText.includes('depo') || headerText.includes('mÃ¼ÅŸteri')) {
                        console.log('âœ… Header row confirmed at index 2');
                    } else {
                        console.log('âš ï¸ Expected headers not found at row 2, using default');
                    }
                }
            }
            
            console.log('ğŸ“ Selected headerRowIndex:', headerRowIndex);
            console.log('ğŸ“ Raw header row:', jsonData[headerRowIndex]);

            const headers = jsonData[headerRowIndex];
            // Data starts after the header row (row 3+ in 0-based indexing)
            const dataRows = jsonData.slice(headerRowIndex + 1); // Skip title, date and headers
            
            console.log('ğŸ“Š Total data rows to process:', dataRows.length);
            console.log('ğŸ“‹ First 3 data rows:', dataRows.slice(0, 3));

            // Map column indices based on Excel analysis
            // Excel structure: Row 0 = Date, Row 1 = Headers, Row 2+ = Data
            // Headers: "Belge No", "Tarih", "Depo", "MÃ¼ÅŸteri", "Åube", "ÃœrÃ¼n", "Kod", "Miktar", "Birim", "Net", "TOPLAM", Currency
            const columnMap = {
                belgeNo: 0,    // Column A: "SATIÅ RAPORU" / "Belge No" 
                tarih: 1,      // Column B: "Unnamed: 1" / "Tarih" 
                depo: 2,       // Column C: "Unnamed: 2" / "Depo"
                musteri: 3,    // Column D: "Unnamed: 3" / "MÃ¼ÅŸteri"  
                sube: 4,       // Column E: "Unnamed: 4" / "Åube"
                urun: 5,       // Column F: "Unnamed: 5" / "ÃœrÃ¼n"
                kod: 6,        // Column G: "Unnamed: 6" / "Kod"
                miktar: 7,     // Column H: "Unnamed: 7" / "Miktar"
                birim: 8,      // Column I: "Unnamed: 8" / "Birim"
                net: 9,        // Column J: "Unnamed: 9" / "Net"
                toplam: 10,    // Column K: "Unnamed: 10" / "TOPLAM"
                paraBirimi: 11 // Column L: "Unnamed: 11" / Currency (TL/EUR/USD)
            };

            // Try to find actual column indices if headers are available
            if (headers && headers.length > 5) {
                console.log('ğŸ” Trying to map headers:', headers);
                for (let i = 0; i < headers.length; i++) {
                    const header = String(headers[i] || '').toLowerCase();
                    console.log(`Header ${i}: "${headers[i]}" -> "${header}"`);
                    if (header.includes('belge')) columnMap.belgeNo = i;
                    else if (header.includes('tarih')) columnMap.tarih = i;
                    else if (header.includes('depo')) columnMap.depo = i;
                    else if (header.includes('mÃ¼ÅŸteri') || header.includes('musteri')) columnMap.musteri = i;
                    else if (header.includes('ÅŸube') || header.includes('sube')) columnMap.sube = i;
                    else if (header.includes('Ã¼rÃ¼n') || header.includes('urun')) columnMap.urun = i;
                    else if (header.includes('kod')) columnMap.kod = i;
                    else if (header.includes('miktar')) columnMap.miktar = i;
                    else if (header.includes('birim')) columnMap.birim = i;
                    else if (header.includes('net')) columnMap.net = i;
                    else if (header.includes('toplam')) columnMap.toplam = i;
                }
                console.log('ğŸ¯ Final Column Map after header parsing:', columnMap);
            } else {
                console.log('âŒ Headers not available or too short, using default mapping');
            }

            const sales = [];
            const stores = {};
            const dealers = {};
            const customers = new Set();
            const categories = {}; // Track sales by category
            const uncategorizedItems = []; // Track uncategorized items
            let totalAmount = 0;
            let totalQuantity = 0;
            let bicycleSales = 0;
            let accessorySales = 0;
            let bicycleQuantity = 0;
            let accessoryQuantity = 0;
            let reportPeriod = '';
            let dealerCount = 0;
            let storeCount = 0;
            
            // Find report period from date row (row 1)
            if (jsonData.length > 1 && jsonData[dateRowIndex] && jsonData[dateRowIndex][0]) {
                const dateCell = String(jsonData[dateRowIndex][0]);
                if (dateCell.includes('-') && dateCell.includes('2025')) {
                    reportPeriod = dateCell;
                    console.log('ğŸ“… Report period found:', reportPeriod);
                }
            }
            
            // Fallback: check first row if not found in date row
            if (!reportPeriod && jsonData.length > 0 && jsonData[0][0]) {
                const firstCell = String(jsonData[0][0]);
                if (firstCell.includes('-')) {
                    reportPeriod = firstCell;
                    console.log('ğŸ“… Report period from first row:', reportPeriod);
                }
            }
            
            // Define dealer detection patterns - more comprehensive matching
            const dealerPatterns = [
                { 
                    names: ['ercem akcan', 'ercem', 'akcan'],
                    dealer: 'Ercem Akcan',
                    getCurrency: (paraBirimi) => paraBirimi || 'TL',
                    getType: (paraBirimi) => paraBirimi === 'EUR' ? 'EUR' : paraBirimi === 'USD' ? 'USD' : 'SC Bisiklet'
                },
                {
                    names: ['mert bikestop', 'mert', 'bikestop', 'bÄ±ke stop', 'bike stop', 'dalkÄ±lÄ±Ã§', 'mert dalkÄ±lÄ±Ã§', 'bÄ±ke stop (mert dalkÄ±lÄ±Ã§)', 'bike stop (mert dalkÄ±lÄ±Ã§)'],
                    dealer: 'Mert Bikestop', 
                    getCurrency: (paraBirimi) => paraBirimi || 'TL',
                    getType: (paraBirimi) => paraBirimi || 'TL'
                }
            ];


            // Process each row
            console.log('ğŸ”„ Processing rows:', dataRows.length);
            console.log('ğŸ“‹ Column Map:', columnMap);
            console.log('ğŸ“‹ Headers:', headers);
            console.log('ğŸ“Š Sample dataRows[0-2]:', dataRows.slice(0, 3));
            console.log('ğŸ” First data row details:', dataRows[0]);
            console.log('ğŸ” Second data row details:', dataRows[1]);
            console.log('ğŸ” Third data row details:', dataRows[2]);
            
            // Reset store distribution for this Excel file
            storeDistributor.resetDistribution();
            
            let lastValidCustomer = ''; // Track last valid customer for merged cells
            let lastValidStore = ''; // Track last valid store for merged cells
            let lastValidProduct = ''; // Track last valid product for merged cells
            
            for (let i = 0; i < dataRows.length; i++) {
                const row = dataRows[i];
                if (!row || row.length < 10) {
                    if (i < 5) console.log(`â­ï¸ Skipping row ${i}:`, row);
                    continue;
                }
                
                let depo = String(row[columnMap.depo] || '').trim();
                let musteri = String(row[columnMap.musteri] || '').trim();
                const toplam = parseFloat(String(row[columnMap.toplam] || '').replace(',', '.')) || 0;
                const miktar = parseInt(String(row[columnMap.miktar] || '').replace(',', '.')) || 0;
                let urun = String(row[columnMap.urun] || '').trim();
                let paraBirimi = String(row[columnMap.paraBirimi] || 'TL').trim().toUpperCase();
                const tarih = row[columnMap.tarih];
                
                // Clean and normalize currency values
                if (!paraBirimi || paraBirimi === 'NAN' || paraBirimi === '') {
                    paraBirimi = 'TL'; // Default to TL
                }
                
                // Handle common currency variations
                if (paraBirimi.includes('EUR')) paraBirimi = 'EUR';
                else if (paraBirimi.includes('USD') || paraBirimi.includes('DOLAR')) paraBirimi = 'USD';
                else paraBirimi = 'TL';

                // Enhanced merged cell handling - look backward for valid values
                if (!musteri || musteri.trim() === '' || musteri === 'NaN') {
                    // Look backward in recent rows to find the actual customer
                    if (lastValidCustomer) {
                        musteri = lastValidCustomer;
                    } else {
                        // Search backwards up to 10 rows for customer name
                        for (let backSearch = Math.max(0, i - 10); backSearch < i; backSearch++) {
                            const searchRow = dataRows[backSearch];
                            if (searchRow && searchRow[columnMap.musteri]) {
                                const searchCustomer = String(searchRow[columnMap.musteri]).trim();
                                if (searchCustomer && searchCustomer !== 'NaN' && searchCustomer.length > 2) {
                                    musteri = searchCustomer;
                                    lastValidCustomer = searchCustomer;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    // Update last valid customer
                    lastValidCustomer = musteri;
                }

                if (!depo || depo.trim() === '' || depo === 'NaN') {
                    // Look backward in recent rows to find the actual store
                    if (lastValidStore) {
                        depo = lastValidStore;
                    } else {
                        // Search backwards up to 10 rows for store name
                        for (let backSearch = Math.max(0, i - 10); backSearch < i; backSearch++) {
                            const searchRow = dataRows[backSearch];
                            if (searchRow && searchRow[columnMap.depo]) {
                                const searchStore = String(searchRow[columnMap.depo]).trim();
                                if (searchStore && searchStore !== 'NaN' && searchStore.length > 2) {
                                    depo = searchStore;
                                    lastValidStore = searchStore;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    // Update last valid store
                    lastValidStore = depo;
                }

                // Enhanced product name handling
                if (!urun || urun.trim() === '' || urun === 'NaN') {
                    // Look backward in recent rows to find the actual product name
                    if (lastValidProduct) {
                        urun = lastValidProduct;
                    } else {
                        // Search backwards up to 10 rows for product name
                        for (let backSearch = Math.max(0, i - 10); backSearch < i; backSearch++) {
                            const searchRow = dataRows[backSearch];
                            if (searchRow && searchRow[columnMap.urun]) {
                                const searchProduct = String(searchRow[columnMap.urun]).trim();
                                if (searchProduct && searchProduct !== 'NaN' && searchProduct.length > 2) {
                                    urun = searchProduct;
                                    lastValidProduct = searchProduct;
                                    break;
                                }
                            }
                        }
                    }
                } else {
                    // Update last valid product
                    lastValidProduct = urun;
                }

                if (i < 10) {
                    console.log(`ğŸ“Š Row ${i} data:`, {
                        raw_depo: row[columnMap.depo],
                        raw_musteri: row[columnMap.musteri], 
                        raw_toplam: row[columnMap.toplam],
                        raw_paraBirimi: row[columnMap.paraBirimi],
                        raw_urun: row[columnMap.urun],
                        raw_full_row: row,
                        columnMap: columnMap,
                        processed: { depo, musteri, toplam, miktar, urun, paraBirimi, tarih },
                        merged_cell_tracking: {
                            lastValidCustomer,
                            lastValidStore,
                            lastValidProduct
                        }
                    });
                }

                // Skip invalid rows - Only check TOPLAM for now, ignore empty customer names
                if (!toplam || toplam <= 0) {
                    if (i < 10) console.log(`âŒ Skipping invalid row ${i}:`, { toplam });
                    continue;
                }

                // Use fallback customer name if empty
                if (!musteri || musteri.trim() === '') {
                    musteri = 'Unknown Customer';
                }

                // Handle blank stores - distribute equally to target stores
                if (!depo || depo.trim() === '' || depo === 'Unknown Store') {
                    depo = storeDistributor.distributeBlankStore(amountInTL, miktar);
                }

                if (i < 5) console.log(`âœ… Processing valid row ${i}:`, { musteri, depo, toplam, miktar });

                // Convert to TL if needed (will be recalculated with monthly rates later)
                let amountInTL = toplam;
                if (paraBirimi === 'EUR') {
                    amountInTL = toplam * exchangeRates.EUR;
                } else if (paraBirimi === 'USD') {
                    amountInTL = toplam * exchangeRates.USD;
                }

                // Add to totals
                totalAmount += amountInTL;
                totalQuantity += miktar;

                // Categorize using enhanced method with BizimHesap API
                const productKod = row[columnMap.kod] || '';
                const categoryInfo = categorizeProduct(productKod, urun);
                
                // Track category-specific sales using main categories
                const mainCategoryName = categoryInfo.mainCategory || categoryInfo.category || 'UNCATEGORIZED';
                
                // Track uncategorized items for debugging
                if (mainCategoryName === 'UNCATEGORIZED') {
                    uncategorizedItems.push({
                        product: urun,
                        code: productKod,
                        amount: amountInTL,
                        quantity: miktar,
                        store: depo,
                        customer: musteri
                    });
                }
                
                if (!categories[mainCategoryName]) {
                    categories[mainCategoryName] = {
                        name: mainCategoryName,
                        originalCategory: categoryInfo.category,
                        type: categoryInfo.type,
                        totalTL: 0,
                        quantity: 0,
                        products: new Set(),
                        source: categoryInfo.source || 'unknown',
                        subcategories: new Set(),
                        transactions: [] // Track individual transactions for duplicate check
                    };
                    console.log(`ğŸ“¦ NEW CATEGORY CREATED: "${mainCategoryName}"`);
                }
                
                // Check for potential duplicates
                const transactionKey = `${productKod}-${urun}-${amountInTL}-${miktar}-${musteri}`;
                const existingTransaction = categories[mainCategoryName].transactions.find(t => t.key === transactionKey);
                
                if (existingTransaction) {
                    console.log(`âš ï¸ POTENTIAL DUPLICATE: ${transactionKey} in ${mainCategoryName}`);
                    console.log(`   Previous: Row ${existingTransaction.row}, Current: Row ${i+3}`);
                } else {
                    categories[mainCategoryName].transactions.push({
                        key: transactionKey,
                        row: i+3,
                        amount: amountInTL,
                        quantity: miktar
                    });
                }
                
                categories[mainCategoryName].totalTL += amountInTL;
                categories[mainCategoryName].quantity += miktar;
                categories[mainCategoryName].products.add(urun);
                if (categoryInfo.category) {
                    categories[mainCategoryName].subcategories.add(categoryInfo.category);
                }
                
                // Log category accumulation every 50 items for major categories
                if ((i + 1) % 50 === 0 && (mainCategoryName === 'BÄ°SÄ°KLETLER' || mainCategoryName === 'E-BÄ°KELER')) {
                    console.log(`ğŸ“Š ${mainCategoryName} Progress (Row ${i+3}): â‚º${categories[mainCategoryName].totalTL.toLocaleString()} | ${categories[mainCategoryName].quantity} items | ${categories[mainCategoryName].products.size} unique products`);
                }
                
                // Count bicycles (both regular and e-bikes) vs accessories
                if (mainCategoryName === 'BÄ°SÄ°KLETLER' || mainCategoryName === 'E-BÄ°KELER') {
                    bicycleSales += amountInTL;
                    bicycleQuantity += miktar;
                    console.log(`ğŸš² BICYCLE SALE: ${urun} (${productKod}) = â‚º${amountInTL} | Category: ${mainCategoryName} | Total bicycles: â‚º${bicycleSales} | Total quantity: ${bicycleQuantity}`);
                } else {
                    accessorySales += amountInTL;
                    accessoryQuantity += miktar;
                    console.log(`ğŸ”§ ACCESSORY SALE: ${urun} (${productKod}) = â‚º${amountInTL} | Category: ${mainCategoryName} | Total accessories: â‚º${accessorySales} | Total quantity: ${accessoryQuantity}`);
                }

                if (i < 15) { // More debug for first 15 items  
                    console.log(`ğŸ·ï¸ Row ${i}: "${urun}" (Code: ${productKod}) â†’ ${categoryInfo.type.toUpperCase()} | Main: ${mainCategoryName} | Sub: ${categoryInfo.category} [${categoryInfo.source}] | â‚º${amountInTL.toLocaleString()} | ${miktar} adet`);
                }

                sales.push({
                    belgeNo: row[columnMap.belgeNo],
                    tarih: tarih,
                    depo: depo, // Use processed depo, not raw
                    musteri: musteri, // Use processed musteri, not raw
                    urun: urun, // Use processed urun, not raw
                    miktar: miktar, // Use processed miktar
                    net: parseFloat(row[columnMap.net]) || 0,
                    toplam: toplam, // Original amount in original currency
                    paraBirimi: paraBirimi,
                    amountInTL: amountInTL // Will be recalculated with monthly rates
                });

                // Check if this is a dealer transaction using improved pattern matching
                const customerLower = musteri.toLowerCase().trim();
                let isDealer = false;
                let matchedDealer = null;
                
                if (i < 10) {
                    console.log(`ğŸ¤ Checking dealer patterns for customer: "${musteri}" â†’ "${customerLower}"`);
                }
                
                for (const pattern of dealerPatterns) {
                    // Check if any of the dealer names match
                    const matchedName = pattern.names.find(name => customerLower.includes(name.toLowerCase()));
                    if (matchedName) {
                        isDealer = true;
                        matchedDealer = pattern;
                        
                        if (i < 10) {
                            console.log(`âœ… DEALER MATCH: "${musteri}" matched with pattern "${matchedName}" â†’ ${pattern.dealer}`);
                        }
                        
                        const dealerType = pattern.getType(paraBirimi);
                        const dealerCurrency = pattern.getCurrency(paraBirimi);
                        const dealerKey = `${pattern.dealer} (${dealerType})`;
                        
                        if (!dealers[dealerKey]) {
                            dealers[dealerKey] = {
                                name: pattern.dealer,
                                type: dealerType,
                                currency: dealerCurrency,
                                totalTL: 0,
                                orderCount: 0,
                                customers: new Set()
                            };
                        }
                        
                        dealers[dealerKey].totalTL += amountInTL;
                        dealers[dealerKey].orderCount += 1;
                        dealers[dealerKey].customers.add(musteri);
                        
                        console.log(`ğŸ¤ DEALER: ${musteri} â†’ ${dealerKey} (${paraBirimi}, â‚º${amountInTL.toLocaleString()})`);
                        dealerCount++;
                        break;
                    }
                }
                
                // Only aggregate by store if not a dealer
                if (!isDealer) {
                    const storeName = depo || 'Bilinmeyen';
                    if (!stores[storeName]) {
                        stores[storeName] = {
                            name: storeName,
                            totalTL: 0,
                            orderCount: 0,
                            customers: new Set()
                        };
                    }

                    stores[storeName].totalTL += amountInTL;
                    stores[storeName].orderCount += 1;
                    stores[storeName].customers.add(musteri);
                    
                    console.log(`ğŸª STORE: ${storeName} | ${musteri} | â‚º${amountInTL.toLocaleString()}`);
                    storeCount++;
                }

                customers.add(musteri);
            }

            // Convert Set to Array for categories products and subcategories
            Object.values(categories).forEach(category => {
                category.products = Array.from(category.products);
                category.subcategories = Array.from(category.subcategories || []);
            });

            // Log category summary
            console.log('\nğŸ“Š MAIN CATEGORY ANALYSIS SUMMARY:');
            Object.values(categories)
                .sort((a, b) => b.totalTL - a.totalTL)
                .forEach(cat => {
                    const subCatList = cat.subcategories.length > 0 ? ` (Alt: ${Array.from(cat.subcategories).join(', ')})` : '';
                    const duplicateCount = cat.transactions ? cat.transactions.length - new Set(cat.transactions.map(t => t.key)).size : 0;
                    const duplicateInfo = duplicateCount > 0 ? ` âš ï¸ ${duplicateCount} duplicates` : '';
                    console.log(`  ${cat.name} [${cat.source}]: â‚º${cat.totalTL.toLocaleString('tr-TR')} | ${cat.quantity} adet | ${cat.products.size} Ã§eÅŸit${subCatList}${duplicateInfo}`);
                });
            
            // Summary of potential duplicates
            const totalDuplicates = Object.values(categories).reduce((sum, cat) => {
                const duplicateCount = cat.transactions ? cat.transactions.length - new Set(cat.transactions.map(t => t.key)).size : 0;
                return sum + duplicateCount;
            }, 0);
            
            if (totalDuplicates > 0) {
                console.log(`\nâš ï¸ DUPLICATE DETECTION SUMMARY: Found ${totalDuplicates} potential duplicate transactions across all categories`);
            } else {
                console.log(`\nâœ… DUPLICATE CHECK: No duplicate transactions detected`);
            }

            // Log detailed uncategorized items
            if (uncategorizedItems.length > 0) {
                console.log('\nâš ï¸ UNCATEGORIZED ITEMS DETAILED:');
                uncategorizedItems.forEach((item, index) => {
                    console.log(`  ${index + 1}. "${item.product}" (Code: ${item.code || 'NO CODE'}) | â‚º${item.amount.toLocaleString()} | ${item.quantity} adet | Store: ${item.store || 'Unknown'} | Customer: ${item.customer}`);
                });
                console.log(`\nâš ï¸ Total UNCATEGORIZED: ${uncategorizedItems.length} items, â‚º${uncategorizedItems.reduce((sum, item) => sum + item.amount, 0).toLocaleString()}`);
            }

            console.log(`\nğŸª STORE vs DEALER COUNT: Stores: ${storeCount} transactions | Dealers: ${dealerCount} transactions`);

            const processedData = {
                sales: sales,
                stores: stores,
                dealers: dealers,
                categories: categories,
                totalAmount: totalAmount,
                totalQuantity: totalQuantity,
                bicycleSales: bicycleSales,
                accessorySales: accessorySales,
                bicycleQuantity: bicycleQuantity,
                accessoryQuantity: accessoryQuantity,
                customerCount: customers.size,
                orderCount: sales.length,
                reportPeriod: reportPeriod
            };

            // Add to monthly history for trend analysis
            if (reportPeriod) {
                // Check if this month already exists in history
                const existingIndex = monthlyDataHistory.findIndex(item => item.reportPeriod === reportPeriod);
                if (existingIndex >= 0) {
                    monthlyDataHistory[existingIndex] = processedData; // Update existing
                } else {
                    monthlyDataHistory.push(processedData); // Add new
                }
                console.log(`ğŸ“ˆ Monthly history updated. Total months: ${monthlyDataHistory.length}`);
            }

            // Apply monthly exchange rates to sales data
            console.log('ğŸ”„ Starting monthly exchange rate processing...');
            
            return processedData;
        }

        function recalculateWithMonthlyRates(data) {
            console.log('ğŸ”„ Recalculating totals with monthly exchange rates...');
            
            // Reset totals
            let newTotalAmount = 0;
            let newCategorySales = {};
            let newCategoryQuantities = {};
            let newStoreSales = {};
            let newDealerSales = {};
            let newBicycleSales = 0;
            let newAccessorySales = 0;
            let newBicycleQuantity = 0;
            let newAccessoryQuantity = 0;
            
            // Recalculate everything with updated amountInTL values
            for (const sale of data.sales) {
                newTotalAmount += sale.amountInTL;
                
                // Recalculate category sales and quantities
                const categoryInfo = categorizeProduct(sale.kod || '', sale.urun || '');
                const mainCategoryName = categoryInfo.mainCategory || categoryInfo.category || 'UNCATEGORIZED';
                newCategorySales[mainCategoryName] = (newCategorySales[mainCategoryName] || 0) + sale.amountInTL;
                newCategoryQuantities[mainCategoryName] = (newCategoryQuantities[mainCategoryName] || 0) + (sale.miktar || 0);
                
                // Recalculate store sales
                newStoreSales[sale.depo] = (newStoreSales[sale.depo] || 0) + sale.amountInTL;
                
                // Recalculate dealer sales
                const customerLower = sale.musteri.toLowerCase().trim();
                let isDealer = false;
                
                if (customerLower.includes('ercem') || customerLower.includes('akcan')) {
                    newDealerSales['Ercem Akcan'] = (newDealerSales['Ercem Akcan'] || 0) + sale.amountInTL;
                    isDealer = true;
                } else if (customerLower.includes('mert') || customerLower.includes('bikestop') || customerLower.includes('bÄ±ke stop')) {
                    newDealerSales['Mert Bikestop'] = (newDealerSales['Mert Bikestop'] || 0) + sale.amountInTL;
                    isDealer = true;
                }
                
                // Recalculate bicycle vs accessory sales and quantities based on main categories
                const recalcMainCategory = categoryInfo.mainCategory || categoryInfo.category || 'AKSESUAR';
                if (recalcMainCategory === 'BÄ°SÄ°KLETLER' || recalcMainCategory === 'E-BÄ°KELER') {
                    newBicycleSales += sale.amountInTL;
                    newBicycleQuantity += (sale.miktar || 0);
                } else {
                    newAccessorySales += sale.amountInTL;
                    newAccessoryQuantity += (sale.miktar || 0);
                }
            }
            
            // Update the data object
            data.totalAmount = newTotalAmount;
            data.categorySales = newCategorySales;
            data.storeSales = newStoreSales;
            data.dealerSales = newDealerSales;
            data.bicycleSales = newBicycleSales;
            data.accessorySales = newAccessorySales;
            data.bicycleQuantity = newBicycleQuantity;
            data.accessoryQuantity = newAccessoryQuantity;
            
            // Update category quantities in the categories object
            if (data.categories) {
                for (const [categoryName, quantity] of Object.entries(newCategoryQuantities)) {
                    if (data.categories[categoryName]) {
                        data.categories[categoryName].quantity = quantity;
                        console.log(`ğŸ“Š Updated ${categoryName} quantity: ${quantity} items`);
                    }
                }
            }
            
            console.log(`âœ… Recalculated totals: â‚º${newTotalAmount.toLocaleString()}`);
            console.log(`ğŸš² Recalculated bicycle quantity: ${newBicycleQuantity} (vs ${data.bicycleQuantity})`);
            console.log(`ğŸ”§ Recalculated accessory quantity: ${newAccessoryQuantity} (vs ${data.accessoryQuantity})`);
            return data;
        }

        function showYearlyAnalysis() {
            const allData = excelMemory.getAllData();
            
            if (allData.files.length < 2) {
                alert('YÄ±llÄ±k analiz iÃ§in en az 2 aylÄ±k veri gerekli. LÃ¼tfen daha fazla Excel dosyasÄ± yÃ¼kleyin.');
                return;
            }
            
            // Show yearly analysis
            showYearlyReport(allData);
        }

        function showYearlyReport(allData) {
            // Hide current analysis
            document.getElementById('analysisSection').style.display = 'none';
            
            // Create yearly analysis container if not exists
            let yearlyContainer = document.getElementById('yearlyAnalysis');
            if (!yearlyContainer) {
                yearlyContainer = document.createElement('div');
                yearlyContainer.id = 'yearlyAnalysis';
                yearlyContainer.className = 'section';
                document.querySelector('.container').appendChild(yearlyContainer);
            }
            
            // Sort monthly data
            const sortedMonths = Object.entries(allData.monthlyBreakdown)
                .sort((a, b) => a[0].localeCompare(b[0]));
            
            // Sort categories by sales
            const topCategories = Object.entries(allData.categories)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const monthNames = {
                '01': 'Ocak', '02': 'Åubat', '03': 'Mart', '04': 'Nisan',
                '05': 'MayÄ±s', '06': 'Haziran', '07': 'Temmuz', '08': 'AÄŸustos',
                '09': 'EylÃ¼l', '10': 'Ekim', '11': 'KasÄ±m', '12': 'AralÄ±k'
            };
            
            yearlyContainer.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2>ğŸ“… 2025 YÄ±llÄ±k SatÄ±ÅŸ Analizi</h2>
                    <button onclick="document.getElementById('yearlyAnalysis').style.display='none'; document.getElementById('analysisSection').style.display='block';" class="section-btn">â† Geri DÃ¶n</button>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div style="background: #e8f5e8; padding: 20px; border-radius: 8px; text-align: center;">
                        <h3>ğŸ’° Toplam SatÄ±ÅŸ (TÃ¼m Para Birimleri)</h3>
                        <div style="font-size: 24px; font-weight: bold; color: #27ae60;">${formatCurrency(allData.totalSales, 'TL')}</div>
                        <div style="font-size: 14px; margin-top: 8px; color: #666;">
                            ğŸ‡ºğŸ‡¸ ${currencyConverter.format(currencyConverter.convert(allData.totalSales, 'TL', 'USD'), 'USD')} |
                            ğŸ‡ªğŸ‡º ${currencyConverter.format(currencyConverter.convert(allData.totalSales, 'TL', 'EUR'), 'EUR')}
                        </div>
                        <div style="color: #666; margin-top: 5px;">${allData.files.length} aylÄ±k veri</div>
                    </div>
                    
                    <div style="background: #e8f4f8; padding: 20px; border-radius: 8px; text-align: center;">
                        <h3>ğŸ“¦ Toplam ÃœrÃ¼n</h3>
                        <div style="font-size: 24px; font-weight: bold; color: #3498db;">${allData.totalQuantity.toLocaleString()} adet</div>
                        <div style="color: #666;">TÃ¼m kategoriler</div>
                    </div>
                    
                    <div style="background: #fef9e7; padding: 20px; border-radius: 8px; text-align: center;">
                        <h3>ğŸ“ˆ Ortalama AylÄ±k</h3>
                        <div style="font-size: 24px; font-weight: bold; color: #f39c12;">${formatCurrency(allData.totalSales / allData.files.length, 'TL')}</div>
                        <div style="font-size: 12px; color: #666;">
                            ${currencyConverter.format(currencyConverter.convert(allData.totalSales / allData.files.length, 'TL', 'USD'), 'USD')} |
                            ${currencyConverter.format(currencyConverter.convert(allData.totalSales / allData.files.length, 'TL', 'EUR'), 'EUR')}
                        </div>
                        <div style="color: #666; margin-top: 3px;">AylÄ±k ortalama</div>
                    </div>
                </div>
                
                <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h3>ğŸ“Š AylÄ±k SatÄ±ÅŸ DaÄŸÄ±lÄ±mÄ±</h3>
                    ${sortedMonths.map(([month, amount]) => {
                        const monthName = monthNames[month.split('-')[1]] || month;
                        const percentage = (amount / allData.totalSales * 100).toFixed(1);
                        return `
                            <div style="display: flex; align-items: center; margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 6px;">
                                <div style="min-width: 80px; font-weight: 600;">${monthName}:</div>
                                <div style="flex: 1; background: #e9ecef; height: 25px; border-radius: 12px; margin: 0 15px; position: relative; overflow: hidden;">
                                    <div style="width: ${percentage}%; background: linear-gradient(90deg, #3498db, #2ecc71); height: 100%; border-radius: 12px;"></div>
                                    <span style="position: absolute; top: 50%; left: 10px; transform: translateY(-50%); font-size: 12px; font-weight: 600; color: white;">${formatCurrency(amount, 'TL')} (${percentage}%)</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h3>ğŸ† En Ä°yi Satan Kategoriler (YÄ±llÄ±k)</h3>
                    ${topCategories.map(([category, amount], index) => {
                        const percentage = (amount / allData.totalSales * 100).toFixed(1);
                        const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}.`;
                        return `
                            <div style="display: flex; align-items: center; padding: 12px; margin: 8px 0; background: ${index < 3 ? '#fff3cd' : '#f8f9fa'}; border-radius: 6px; border: 1px solid ${index < 3 ? '#ffeaa7' : '#e9ecef'};">
                                <span style="font-size: 20px; margin-right: 15px;">${medal}</span>
                                <span style="flex: 1; font-weight: 600;">${category}</span>
                                <span style="font-weight: bold; color: #27ae60;">${formatCurrency(amount, 'TL')} (${percentage}%)</span>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h4>ğŸ“š Analiz Edilen Dosyalar</h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px;">
                        ${allData.files.map(file => `<span style="background: #3498db; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px;">${file}</span>`).join('')}
                    </div>
                </div>
            `;
            
            yearlyContainer.style.display = 'block';
        }

        function displayAnalysis() {
            if (!currentData) return;

            // Show analysis section
            document.getElementById('analysisSection').style.display = 'block';

            // Update currency display
            updateCurrencyDisplay();
        }

        function updateCurrencyDisplay() {
            if (!currentData) {
                console.log('âŒ No currentData available');
                return;
            }

            console.log('ğŸ“Š Current Data:', currentData);
            
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? 'â‚º' : currentCurrency === 'USD' ? '$' : 'â‚¬';

            // Update report period
            const periodElement = document.getElementById('periodInfo');
            if (periodElement) {
                periodElement.textContent = `ğŸ“… Rapor DÃ¶nemi: ${currentData.reportPeriod || 'BelirtilmemiÅŸ'}`;
            }

            // Update all statistics with currency conversion
            const totalSalesEl = document.getElementById('totalSales');
            if (totalSalesEl && typeof currentData.totalAmount === 'number') {
                // Show current selected currency as main value
                totalSalesEl.textContent = symbol + (currentData.totalAmount / rate).toLocaleString('tr-TR', { maximumFractionDigits: 0 });
                
                // Update all currency totals
                const allTotals = currencyConverter.getAllTotals(currentData.totalAmount);
                document.getElementById('totalUSD').textContent = currencyConverter.format(allTotals.USD, 'USD');
                document.getElementById('totalEUR').textContent = currencyConverter.format(allTotals.EUR, 'EUR');
                document.getElementById('totalTL').textContent = currencyConverter.format(allTotals.TL, 'TL');
                
                console.log('âœ… Total Sales Updated:', totalSalesEl.textContent);
                console.log('ğŸ’± Currency Breakdown:', allTotals);
                
                // Show store distribution stats
                const distStats = storeDistributor.getDistributionStats();
                console.log('ğŸ“ Store Distribution Stats:', distStats);
            }

            const totalQuantityEl = document.getElementById('totalQuantity');
            if (totalQuantityEl && typeof currentData.totalQuantity === 'number') {
                totalQuantityEl.textContent = currentData.totalQuantity.toLocaleString('tr-TR') + ' adet';
                console.log('âœ… Total Quantity Updated:', totalQuantityEl.textContent);
            }

            const bicycleSalesEl = document.getElementById('bicycleSales');
            if (bicycleSalesEl && typeof currentData.bicycleSales === 'number') {
                bicycleSalesEl.textContent = symbol + (currentData.bicycleSales / rate).toLocaleString('tr-TR', { maximumFractionDigits: 0 });
            }

            const accessorySalesEl = document.getElementById('accessorySales');
            if (accessorySalesEl && typeof currentData.accessorySales === 'number') {
                accessorySalesEl.textContent = symbol + (currentData.accessorySales / rate).toLocaleString('tr-TR', { maximumFractionDigits: 0 });
            }

            const bicycleQuantityEl = document.getElementById('bicycleQuantity');
            if (bicycleQuantityEl && typeof currentData.bicycleQuantity === 'number') {
                bicycleQuantityEl.textContent = currentData.bicycleQuantity.toLocaleString('tr-TR') + ' adet';
            }

            const accessoryQuantityEl = document.getElementById('accessoryQuantity');
            if (accessoryQuantityEl && typeof currentData.accessoryQuantity === 'number') {
                accessoryQuantityEl.textContent = currentData.accessoryQuantity.toLocaleString('tr-TR') + ' adet';
            }

            // Debug: Check individual category quantities
            if (currentData.categories) {
                console.log('\nğŸ“Š === CATEGORY QUANTITIES DEBUG ===');
                const categoryNames = ['BÄ°SÄ°KLETLER', 'E-BÄ°KELER', 'AKSESUAR', 'YEDEK PARÃ‡A', 'TEKSTÄ°L', 'BIKE FIT'];
                for (const catName of categoryNames) {
                    if (currentData.categories[catName]) {
                        console.log(`ğŸ“¦ ${catName}: ${currentData.categories[catName].quantity} adet (â‚º${currentData.categories[catName].totalTL.toLocaleString()})`);
                    } else {
                        console.log(`ğŸ“¦ ${catName}: 0 adet (category not found)`);
                    }
                }
                
                // Verify bicycle + accessory totals
                const bicycleTotal = (currentData.categories['BÄ°SÄ°KLETLER']?.quantity || 0) + (currentData.categories['E-BÄ°KELER']?.quantity || 0);
                const accessoryTotal = (currentData.categories['AKSESUAR']?.quantity || 0) + 
                                     (currentData.categories['YEDEK PARÃ‡A']?.quantity || 0) + 
                                     (currentData.categories['TEKSTÄ°L']?.quantity || 0) + 
                                     (currentData.categories['BIKE FIT']?.quantity || 0);
                
                console.log(`ğŸš² Calculated Bicycle Total: ${bicycleTotal} (Dashboard shows: ${currentData.bicycleQuantity})`);
                console.log(`ğŸ”§ Calculated Accessory Total: ${accessoryTotal} (Dashboard shows: ${currentData.accessoryQuantity})`);
                console.log(`ğŸ“¦ Grand Total: ${bicycleTotal + accessoryTotal} (Dashboard shows: ${currentData.totalQuantity})`);
                console.log('=================================\n');
            }

            const storeCountEl = document.getElementById('storeCount');
            if (storeCountEl && currentData.stores && currentData.dealers) {
                storeCountEl.textContent = (Object.keys(currentData.stores).length + Object.keys(currentData.dealers).length).toLocaleString('tr-TR');
            }

            const customerCountEl = document.getElementById('customerCount');
            if (customerCountEl && typeof currentData.customerCount === 'number') {
                customerCountEl.textContent = currentData.customerCount.toLocaleString('tr-TR');
            }

            // Update stores list
            updateStoresList();
            
            // Update dealers list
            updateDealersList();
            
            // Update chart
            updateChart();
        }

        function updateStoresList() {
            if (!currentData) return;
            
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? 'â‚º' : currentCurrency === 'USD' ? '$' : 'â‚¬';
            
            const storesList = document.getElementById('storesList');
            storesList.innerHTML = '';

            // Sort stores by sales amount
            const sortedStores = Object.values(currentData.stores)
                .sort((a, b) => b.totalTL - a.totalTL);

            sortedStores.forEach(store => {
                const storeDiv = document.createElement('div');
                storeDiv.className = 'store-item';
                
                const amount = store.totalTL / rate;
                
                storeDiv.innerHTML = `
                    <div class="store-name">${store.name}</div>
                    <div class="store-stats">
                        <div class="store-amount">${symbol}${amount.toLocaleString('tr-TR', { maximumFractionDigits: 0 })}</div>
                        <div class="store-count">${store.orderCount} sipariÅŸ</div>
                        <div class="store-count">${store.customers.size} mÃ¼ÅŸteri</div>
                    </div>
                `;
                
                storesList.appendChild(storeDiv);
            });
        }

        function updateDealersList() {
            if (!currentData) return;
            
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? 'â‚º' : currentCurrency === 'USD' ? '$' : 'â‚¬';
            
            const dealersList = document.getElementById('dealersList');
            dealersList.innerHTML = '';

            // Sort dealers by sales amount
            const sortedDealers = Object.values(currentData.dealers)
                .sort((a, b) => b.totalTL - a.totalTL);

            sortedDealers.forEach(dealer => {
                const dealerDiv = document.createElement('div');
                dealerDiv.className = 'dealer-item';
                
                const amount = dealer.totalTL / rate;
                
                dealerDiv.innerHTML = `
                    <div>
                        <span class="dealer-name">${dealer.name}</span>
                        <span class="dealer-type">${dealer.type}</span>
                    </div>
                    <div class="store-stats">
                        <div class="store-amount">${symbol}${amount.toLocaleString('tr-TR', { maximumFractionDigits: 0 })}</div>
                        <div class="store-count">${dealer.orderCount} sipariÅŸ</div>
                        <div class="store-count">${dealer.customers.size} mÃ¼ÅŸteri</div>
                    </div>
                `;
                
                dealersList.appendChild(dealerDiv);
            });
        }

        function updateChart() {
            updateStoresChart();
            updateCategoryChart();
            updatePerformanceChart();
            updateMonthlyTrendChart();
        }

        function updateStoresChart() {
            if (!currentData) return;
            
            const ctx = document.getElementById('salesChart').getContext('2d');
            
            // Prepare data for chart
            const storeNames = Object.values(currentData.stores).map(store => store.name);
            const storeAmounts = Object.values(currentData.stores).map(store => store.totalTL);
            
            const dealerNames = Object.values(currentData.dealers).map(dealer => `${dealer.name} (${dealer.type})`);
            const dealerAmounts = Object.values(currentData.dealers).map(dealer => dealer.totalTL);
            
            // Destroy existing chart if it exists
            if (salesChartInstance) {
                salesChartInstance.destroy();
            }
            
            // Create new chart
            salesChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [...storeNames, ...dealerNames],
                    datasets: [{
                        label: 'SatÄ±ÅŸ TutarÄ± (TL)',
                        data: [...storeAmounts, ...dealerAmounts],
                        backgroundColor: [
                            ...storeNames.map(() => '#3498db'),
                            ...dealerNames.map(() => '#27ae60')
                        ],
                        borderColor: [
                            ...storeNames.map(() => '#2980b9'),
                            ...dealerNames.map(() => '#229954')
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return 'â‚º' + value.toLocaleString('tr-TR');
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        function updateCategoryChart() {
            if (!currentData || !currentData.categories) return;
            
            const ctx = document.getElementById('categoryChart').getContext('2d');
            
            // Sort categories by sales amount and get top 8
            const sortedCategories = Object.values(currentData.categories)
                .sort((a, b) => b.totalTL - a.totalTL)
                .slice(0, 8);
            
            const categoryNames = sortedCategories.map(cat => {
                // Add emoji and short name for better visualization
                if (cat.name === 'BÄ°SÄ°KLETLER') return 'ğŸš² Bisikletler';
                if (cat.name === 'E-BÄ°KELER') return 'âš¡ E-Bisikletler';
                if (cat.name === 'POMPA') return 'ğŸŒ¬ï¸ Pompa';
                if (cat.name === 'KASK') return 'ğŸª– Kask';
                if (cat.name === 'AYDINLATMA') return 'ğŸ’¡ AydÄ±nlatma';
                if (cat.name === 'BAGAJ - SEPET') return 'ğŸ§³ Bagaj/Sepet';
                if (cat.name === 'LASTÄ°K') return 'ğŸ› Lastik';
                if (cat.name === 'PEDAL') return 'ğŸ¦¶ Pedal';
                if (cat.name === 'GÃ–ZLÃœK ğŸ‘“') return 'ğŸ•¶ï¸ GÃ¶zlÃ¼k';
                if (cat.name === 'FORMA') return 'ğŸ‘• Forma';
                if (cat.name === 'ELDÄ°VEN') return 'ğŸ§¤ Eldiven';
                if (cat.name === 'MATARA') return 'ğŸ¶ Matara';
                if (cat.name === 'KÄ°LÄ°T') return 'ğŸ”’ Kilit';
                if (cat.name === 'Ã‡AMURLUK') return 'ğŸ›¡ï¸ Ã‡amurluk';
                return cat.name;
            });
            
            const categoryAmounts = sortedCategories.map(cat => cat.totalTL);
            
            // Modern color palette with gradients
            const categoryColors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', 
                '#FFEAA7', '#DDA0DD', '#FFB347', '#87CEEB'
            ];
            
            const borderColors = [
                '#FF5252', '#26A69A', '#2196F3', '#66BB6A',
                '#FFD54F', '#BA68C8', '#FF9800', '#64B5F6'
            ];
            
            // Destroy existing chart if it exists
            if (categoryChartInstance) {
                categoryChartInstance.destroy();
            }
            
            // Create modern doughnut chart with enhanced styling
            categoryChartInstance = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: categoryNames,
                    datasets: [{
                        data: categoryAmounts,
                        backgroundColor: categoryColors.slice(0, sortedCategories.length),
                        borderColor: borderColors.slice(0, sortedCategories.length),
                        borderWidth: 3,
                        hoverBorderWidth: 5,
                        cutout: '60%'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'right',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: {
                                    size: 12,
                                    weight: '500'
                                },
                                generateLabels: function(chart) {
                                    const data = chart.data;
                                    const total = data.datasets[0].data.reduce((a, b) => a + b, 0);
                                    
                                    return data.labels.map((label, i) => {
                                        const value = data.datasets[0].data[i];
                                        const percentage = ((value / total) * 100).toFixed(1);
                                        
                                        return {
                                            text: `${label} (${percentage}%)`,
                                            fillStyle: data.datasets[0].backgroundColor[i],
                                            strokeStyle: data.datasets[0].borderColor[i],
                                            lineWidth: 2,
                                            pointStyle: 'circle',
                                            index: i
                                        };
                                    });
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: '#fff',
                            borderWidth: 1,
                            cornerRadius: 8,
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    const rate = exchangeRates[currentCurrency];
                                    const symbol = currentCurrency === 'TL' ? 'â‚º' : currentCurrency === 'USD' ? '$' : 'â‚¬';
                                    const convertedValue = (value / rate);
                                    
                                    return [
                                        `${context.label}`,
                                        `${symbol}${convertedValue.toLocaleString('tr-TR', { maximumFractionDigits: 0 })}`,
                                        `${percentage}% of total sales`
                                    ];
                                }
                            }
                        }
                    },
                    animation: {
                        animateRotate: true,
                        animateScale: true,
                        duration: 1000,
                        easing: 'easeOutCubic'
                    },
                    onHover: (event, activeElements) => {
                        event.native.target.style.cursor = activeElements.length > 0 ? 'pointer' : 'default';
                    },
                    onClick: (event, activeElements) => {
                        if (activeElements.length > 0) {
                            const index = activeElements[0].index;
                            const categoryName = sortedCategories[index].name;
                            showCategoryDetail(categoryName);
                        }
                    }
                }
            });
            
            // Add center text with total sales
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? 'â‚º' : currentCurrency === 'USD' ? '$' : 'â‚¬';
            const totalSales = categoryAmounts.reduce((a, b) => a + b, 0);
            const convertedTotal = (totalSales / rate);
            
            // Custom plugin for center text
            Chart.register({
                id: 'centerText',
                beforeDraw: function(chart) {
                    if (chart.config.type === 'doughnut') {
                        const ctx = chart.ctx;
                        const centerX = (chart.chartArea.left + chart.chartArea.right) / 2;
                        const centerY = (chart.chartArea.top + chart.chartArea.bottom) / 2;
                        
                        ctx.save();
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // Total sales text
                        ctx.font = 'bold 16px Arial';
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillText('Toplam SatÄ±ÅŸ', centerX, centerY - 15);
                        
                        // Amount text
                        ctx.font = 'bold 20px Arial';
                        ctx.fillStyle = '#e74c3c';
                        ctx.fillText(`${symbol}${convertedTotal.toLocaleString('tr-TR', { maximumFractionDigits: 0 })}`, centerX, centerY + 10);
                        
                        ctx.restore();
                    }
                }
            });
            
            // Update summary cards
            updateCategorySummaryCards(sortedCategories);
            
            // Update category details table
            updateCategoryDetailsTable(Object.values(currentData.categories));
        }
        
        function updateCategorySummaryCards(sortedCategories) {
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? 'â‚º' : currentCurrency === 'USD' ? '$' : 'â‚¬';
            
            // Top category
            if (sortedCategories.length > 0) {
                const topCategory = sortedCategories[0];
                document.getElementById('topCategoryName').textContent = topCategory.name;
                const convertedAmount = (topCategory.totalTL / rate);
                document.getElementById('topCategoryAmount').textContent = 
                    `${symbol}${convertedAmount.toLocaleString('tr-TR', { maximumFractionDigits: 0 })}`;
            }
            
            // Total categories count
            document.getElementById('totalCategoriesCount').textContent = Object.keys(currentData.categories).length;
            
            // Bike vs Accessory ratio
            const bikeCategories = ['BÄ°SÄ°KLETLER', 'E-BÄ°KELER'];
            let bikeTotal = 0, accessoryTotal = 0;
            
            Object.values(currentData.categories).forEach(cat => {
                if (bikeCategories.includes(cat.name)) {
                    bikeTotal += cat.totalTL;
                } else {
                    accessoryTotal += cat.totalTL;
                }
            });
            
            const total = bikeTotal + accessoryTotal;
            if (total > 0) {
                const bikePercentage = ((bikeTotal / total) * 100).toFixed(1);
                const accessoryPercentage = ((accessoryTotal / total) * 100).toFixed(1);
                document.getElementById('bikeAccessoryRatio').textContent = `${bikePercentage}% / ${accessoryPercentage}%`;
            }
        }
        
        function updateCategoryDetailsTable(categories) {
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? 'â‚º' : currentCurrency === 'USD' ? '$' : 'â‚¬';
            const totalSales = categories.reduce((sum, cat) => sum + cat.totalTL, 0);
            
            const tableBody = document.getElementById('categoryTableBody');
            tableBody.innerHTML = '';
            
            // Sort categories by sales amount
            const sortedCategories = categories.sort((a, b) => b.totalTL - a.totalTL);
            
            sortedCategories.forEach((category, index) => {
                const convertedAmount = (category.totalTL / rate);
                const percentage = ((category.totalTL / totalSales) * 100).toFixed(1);
                const productCount = category.subcategories ? category.subcategories.length : 1;
                
                const row = document.createElement('tr');
                row.style.backgroundColor = index % 2 === 0 ? '#f8f9fa' : 'white';
                row.innerHTML = `
                    <td style="padding: 12px; font-weight: 500;">${getCategoryEmoji(category.name)} ${category.name}</td>
                    <td style="padding: 12px; text-align: right; font-weight: bold;">${symbol}${convertedAmount.toLocaleString('tr-TR', { maximumFractionDigits: 0 })}</td>
                    <td style="padding: 12px; text-align: right; color: #7f8c8d;">${percentage}%</td>
                    <td style="padding: 12px; text-align: right; color: #95a5a6;">${productCount}</td>
                `;
                tableBody.appendChild(row);
            });
            
            // Show table
            document.getElementById('categoryDetailsTable').style.display = 'block';
        }
        
        function getCategoryEmoji(categoryName) {
            const emojiMap = {
                'BÄ°SÄ°KLETLER': 'ğŸš²',
                'E-BÄ°KELER': 'âš¡',
                'AKSESUAR': 'ğŸ“¦',
                'YEDEK PARÃ‡A': 'ğŸ”§',
                'TEKSTÄ°L': 'ğŸ‘•',
                'BIKE FIT': 'ğŸ› ï¸'
            };
            return emojiMap[categoryName] || 'ğŸ“¦';
        }

        function getCategoryColor(categoryName) {
            const colorMap = {
                'BÄ°SÄ°KLETLER': '#e74c3c',
                'E-BÄ°KELER': '#f39c12', 
                'AKSESUAR': '#3498db',
                'YEDEK PARÃ‡A': '#9b59b6',
                'TEKSTÄ°L': '#1abc9c',
                'BIKE FIT': '#34495e'
            };
            return colorMap[categoryName] || '#95a5a6';
        }

        function getCategoryIcon(categoryName) {
            const iconMap = {
                'BÄ°SÄ°KLETLER': 'ğŸš² Normal Bisiklet',
                'E-BÄ°KELER': 'âš¡ Elektrikli Bisiklet',
                'AKSESUAR': 'ğŸ“¦ Aksesuar',
                'YEDEK PARÃ‡A': 'ğŸ”§ Yedek ParÃ§a',
                'TEKSTÄ°L': 'ğŸ‘• Tekstil/Giyim',
                'BIKE FIT': 'ğŸ› ï¸ Hizmet/Bike Fit'
            };
            return iconMap[categoryName] || 'ğŸ“¦ DiÄŸer';
        }
        
        function exportCategoryData() {
            if (!currentData || !currentData.categories) {
                alert('HenÃ¼z analiz edilmiÅŸ veri yok!');
                return;
            }
            
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? 'â‚º' : currentCurrency === 'USD' ? '$' : 'â‚¬';
            
            let csvContent = 'Kategori,SatÄ±ÅŸ MiktarÄ±,YÃ¼zde,Alt Kategoriler\n';
            const totalSales = Object.values(currentData.categories).reduce((sum, cat) => sum + cat.totalTL, 0);
            
            Object.values(currentData.categories)
                .sort((a, b) => b.totalTL - a.totalTL)
                .forEach(category => {
                    const convertedAmount = (category.totalTL / rate);
                    const percentage = ((category.totalTL / totalSales) * 100).toFixed(1);
                    const subcategories = category.subcategories ? Array.from(category.subcategories).join('; ') : '';
                    
                    csvContent += `"${category.name}","${symbol}${convertedAmount.toLocaleString('tr-TR')}","${percentage}%","${subcategories}"\n`;
                });
            
            // Download CSV
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `kategori-analizi-${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
        }

        function updatePerformanceChart() {
            if (!currentData || !currentData.categories) return;
            
            const ctx = document.getElementById('performanceChartCanvas').getContext('2d');
            const analysisDiv = document.getElementById('performanceAnalysis');
            
            // Sort categories by performance (sales amount)
            const sortedCategories = Object.values(currentData.categories)
                .sort((a, b) => b.totalTL - a.totalTL)
                .slice(0, 5); // Top 5 categories
            
            // Update performance analysis cards
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? 'â‚º' : currentCurrency === 'USD' ? '$' : 'â‚¬';
            
            analysisDiv.innerHTML = sortedCategories.map((category, index) => `
                <div class="performance-card" onclick="showCategoryDetail('${category.name}')" style="cursor: pointer;">
                    <div class="performance-category">
                        ${index + 1}. ${category.name} 
                        <span style="color: ${getCategoryColor(category.name)}; font-size: 12px;">
                            ${getCategoryIcon(category.name)}
                        </span>
                        ${category.subcategories && category.subcategories.length > 0 ? 
                            `<div style="font-size: 11px; color: #666; margin-top: 4px;">Alt: ${category.subcategories.join(', ')}</div>` : ''}
                    </div>
                    <div class="performance-stats">
                        <div class="performance-amount">${symbol}${(category.totalTL / rate).toLocaleString('tr-TR', { maximumFractionDigits: 0 })}</div>
                        <div class="performance-count">${category.quantity} adet</div>
                        <div class="performance-count">${category.products.length} Ã§eÅŸit Ã¼rÃ¼n</div>
                    </div>
                </div>
            `).join('');
            
            // Create bar chart
            const categoryNames = sortedCategories.map(cat => cat.name);
            const categoryAmounts = sortedCategories.map(cat => cat.totalTL);
            
            // Destroy existing chart if it exists
            if (performanceChartInstance) {
                performanceChartInstance.destroy();
            }
            
            // Create new chart
            performanceChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: categoryNames,
                    datasets: [{
                        label: 'SatÄ±ÅŸ TutarÄ± (TL)',
                        data: categoryAmounts,
                        backgroundColor: '#27ae60',
                        borderColor: '#229954',
                        borderWidth: 1
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    scales: {
                        x: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return 'â‚º' + value.toLocaleString('tr-TR');
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }

        function updateMonthlySalesChart() {
            // Get all files from memory to create monthly trend
            const allData = excelMemory.getAllData();
            const monthlyBreakdown = allData.monthlyBreakdown;
            
            if (Object.keys(monthlyBreakdown).length < 1) {
                // Show message if no data
                const statsDiv = document.getElementById('monthlyStatsContent');
                if (statsDiv) {
                    statsDiv.innerHTML = '<div style="color: #666; font-style: italic;">AylÄ±k trend iÃ§in en az 1 aylÄ±k veri gerekli.</div>';
                }
                return;
            }
            
            const canvas = document.getElementById('monthlySalesCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Sort months chronologically
            const sortedMonths = Object.entries(monthlyBreakdown)
                .sort((a, b) => a[0].localeCompare(b[0]));
            
            const monthNames = {
                '01': 'Ocak', '02': 'Åubat', '03': 'Mart', '04': 'Nisan',
                '05': 'MayÄ±s', '06': 'Haziran', '07': 'Temmuz', '08': 'AÄŸustos',
                '09': 'EylÃ¼l', '10': 'Ekim', '11': 'KasÄ±m', '12': 'AralÄ±k'
            };
            
            // Convert TL amounts to USD
            const labels = [];
            const dataUSD = [];
            const dataTL = [];
            
            for (const [monthKey, tlAmount] of sortedMonths) {
                const [year, month] = monthKey.split('-');
                const monthName = monthNames[month] || month;
                labels.push(`${monthName} ${year}`);
                
                // Convert to USD using currency converter
                const usdAmount = currencyConverter.convert(tlAmount, 'TL', 'USD');
                dataUSD.push(usdAmount);
                dataTL.push(tlAmount);
            }
            
            // Calculate statistics
            const totalUSD = dataUSD.reduce((sum, val) => sum + val, 0);
            const avgUSD = totalUSD / dataUSD.length;
            const maxUSD = Math.max(...dataUSD);
            const minUSD = Math.min(...dataUSD);
            const maxMonth = labels[dataUSD.indexOf(maxUSD)];
            const minMonth = labels[dataUSD.indexOf(minUSD)];
            
            // Growth calculation
            let growthText = '';
            if (dataUSD.length > 1) {
                const lastMonth = dataUSD[dataUSD.length - 1];
                const prevMonth = dataUSD[dataUSD.length - 2];
                const growth = ((lastMonth - prevMonth) / prevMonth * 100).toFixed(1);
                const growthColor = growth >= 0 ? '#27ae60' : '#e74c3c';
                const growthIcon = growth >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰';
                growthText = `<div style="color: ${growthColor};">${growthIcon} Son aya gÃ¶re: %${growth}</div>`;
            }
            
            // Update statistics
            const statsDiv = document.getElementById('monthlyStatsContent');
            if (statsDiv) {
                statsDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <div><strong>ğŸ’° Toplam:</strong> ${currencyConverter.format(totalUSD, 'USD')}</div>
                            <div><strong>ğŸ“Š Ortalama:</strong> ${currencyConverter.format(avgUSD, 'USD')}</div>
                            <div><strong>ğŸ“ˆ En YÃ¼ksek:</strong> ${currencyConverter.format(maxUSD, 'USD')} <span style="color: #666;">(${maxMonth})</span></div>
                        </div>
                        <div>
                            <div><strong>ğŸ“‰ En DÃ¼ÅŸÃ¼k:</strong> ${currencyConverter.format(minUSD, 'USD')} <span style="color: #666;">(${minMonth})</span></div>
                            <div><strong>ğŸ“… DÃ¶nem:</strong> ${labels.length} ay</div>
                            ${growthText}
                        </div>
                    </div>
                `;
            }
            
            // Destroy existing chart
            if (monthlySalesChartInstance) {
                monthlySalesChartInstance.destroy();
            }
            
            // Create gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, 400);
            gradient.addColorStop(0, 'rgba(52, 152, 219, 0.8)');
            gradient.addColorStop(1, 'rgba(52, 152, 219, 0.1)');
            
            // Create new chart
            monthlySalesChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'AylÄ±k SatÄ±ÅŸ (USD)',
                        data: dataUSD,
                        borderColor: '#3498db',
                        backgroundColor: gradient,
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: '#3498db',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            callbacks: {
                                label: function(context) {
                                    const index = context.dataIndex;
                                    const usdVal = currencyConverter.format(context.raw, 'USD');
                                    const tlVal = currencyConverter.format(dataTL[index], 'TL');
                                    return [
                                        `USD: ${usdVal}`,
                                        `TL: ${tlVal}`
                                    ];
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Aylar'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'SatÄ±ÅŸ TutarÄ± (USD)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toLocaleString();
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateMonthlyTrendChart() {
            if (monthlyDataHistory.length < 2) {
                // Not enough data for trend analysis
                return;
            }
            
            const ctx = document.getElementById('monthlyTrendChart').getContext('2d');
            
            // Get all unique categories from all months
            const allCategories = new Set();
            monthlyDataHistory.forEach(monthData => {
                Object.keys(monthData.categories || {}).forEach(cat => allCategories.add(cat));
            });
            
            // Prepare trend data for top categories
            const topCategories = Array.from(allCategories).slice(0, 5);
            const datasets = [];
            const colors = ['#3498db', '#e74c3c', '#27ae60', '#f39c12', '#9b59b6'];
            
            topCategories.forEach((category, index) => {
                const data = monthlyDataHistory.map(monthData => {
                    return monthData.categories[category]?.totalTL || 0;
                });
                
                datasets.push({
                    label: category,
                    data: data,
                    borderColor: colors[index],
                    backgroundColor: colors[index] + '20',
                    fill: false,
                    tension: 0.1
                });
            });
            
            // Destroy existing chart if it exists
            if (monthlyTrendChartInstance) {
                monthlyTrendChartInstance.destroy();
            }
            
            // Create new chart
            monthlyTrendChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: monthlyDataHistory.map(data => data.reportPeriod || 'Bilinmeyen'),
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return 'â‚º' + value.toLocaleString('tr-TR');
                                }
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        function showChart(chartType) {
            // Update button states
            document.querySelectorAll('.chart-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Show/hide chart containers
            document.getElementById('storesChart').style.display = chartType === 'stores' ? 'block' : 'none';
            document.getElementById('categoriesChart').style.display = chartType === 'categories' ? 'block' : 'none';
            document.getElementById('performanceChart').style.display = chartType === 'performance' ? 'block' : 'none';
            document.getElementById('monthlyChart').style.display = chartType === 'monthly' ? 'block' : 'none';
            document.getElementById('monthlySalesChart').style.display = chartType === 'monthlySales' ? 'block' : 'none';
            
            // Update monthly sales chart if selected
            if (chartType === 'monthlySales') {
                updateMonthlySalesChart();
            }
        }

        function showCategoryDetail(categoryName) {
            if (!currentData || !currentData.categories || !currentData.categories[categoryName]) {
                alert('Kategori detaylarÄ± bulunamadÄ±');
                return;
            }
            
            const category = currentData.categories[categoryName];
            const rate = exchangeRates[currentCurrency];
            const symbol = currentCurrency === 'TL' ? 'â‚º' : currentCurrency === 'USD' ? '$' : 'â‚¬';
            
            // Filter sales for this category
            const categorySales = currentData.sales.filter(sale => {
                // Check if this sale belongs to the category
                const productKod = sale.kod || '';
                const categoryInfo = categorizeProduct(productKod, sale.urun);
                const mainCategoryName = categoryInfo.mainCategory || categoryInfo.category || 'UNCATEGORIZED';
                return mainCategoryName === categoryName;
            });
            
            // Group by store/dealer
            const salesByLocation = {};
            categorySales.forEach(sale => {
                const location = sale.depo || 'Bilinmeyen';
                if (!salesByLocation[location]) {
                    salesByLocation[location] = { sales: 0, quantity: 0, orders: 0 };
                }
                salesByLocation[location].sales += sale.amountInTL || 0;
                salesByLocation[location].quantity += sale.miktar || 0;
                salesByLocation[location].orders += 1;
            });
            
            // Create detail popup
            let detailHTML = `
                <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                           background: white; padding: 30px; border-radius: 15px; 
                           box-shadow: 0 10px 40px rgba(0,0,0,0.3); z-index: 1000; max-width: 600px; max-height: 70vh; overflow-y: auto;">
                    <div style="display: flex; justify-content: between; align-items: center; margin-bottom: 20px;">
                        <h2>ğŸ“Š ${categoryName} DetaylarÄ±</h2>
                        <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                                style="background: #e74c3c; color: white; border: none; border-radius: 50%; 
                                       width: 30px; height: 30px; cursor: pointer; margin-left: auto;">Ã—</button>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <strong>Toplam:</strong> ${symbol}${(category.totalTL / rate).toLocaleString('tr-TR')} | 
                        <strong>Adet:</strong> ${category.quantity} | 
                        <strong>Ã‡eÅŸit:</strong> ${category.products.length}
                        ${category.subcategories.length > 0 ? `<br><strong>Alt Kategoriler:</strong> ${category.subcategories.join(', ')}` : ''}
                    </div>
                    
                    <h3>ğŸ“ Lokasyon BazÄ±nda SatÄ±ÅŸlar:</h3>
                    <div style="max-height: 300px; overflow-y: auto;">
            `;
            
            Object.entries(salesByLocation)
                .sort(([,a], [,b]) => b.sales - a.sales)
                .forEach(([location, data]) => {
                    detailHTML += `
                        <div style="display: flex; justify-content: space-between; padding: 10px; border-bottom: 1px solid #eee;">
                            <strong>${location}</strong>
                            <div>
                                ${symbol}${(data.sales / rate).toLocaleString('tr-TR')} | 
                                ${data.quantity} adet | 
                                ${data.orders} sipariÅŸ
                            </div>
                        </div>
                    `;
                });
            
            detailHTML += `</div></div>`;
            
            // Create overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999;';
            overlay.onclick = () => overlay.remove();
            
            overlay.innerHTML = detailHTML;
            document.body.appendChild(overlay);
        }

        function toggleCurrency(currency) {
            currentCurrency = currency;
            
            // Update button states
            document.querySelectorAll('.currency-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Update display
            updateCurrencyDisplay();
        }

        function showSection(section) {
            // Update button states
            document.querySelectorAll('.section-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Show/hide tabs
            document.getElementById('storesTab').style.display = section === 'stores' ? 'block' : 'none';
            document.getElementById('dealersTab').style.display = section === 'dealers' ? 'block' : 'none';
        }

        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error';
            errorDiv.textContent = message;
            document.querySelector('.upload-section').appendChild(errorDiv);
            
            setTimeout(() => {
                errorDiv.remove();
            }, 5000);
        }

        function showSuccess(message) {
            const successDiv = document.createElement('div');
            successDiv.className = 'success';
            successDiv.textContent = message;
            document.querySelector('.upload-section').appendChild(successDiv);
            
            setTimeout(() => {
                successDiv.remove();
            }, 3000);
        }
    </script>
</body>
</html>